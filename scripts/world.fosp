                                                                                   

bool LocIsModoc(uint locPid)
{
	return(locPid<=(1253));
}

bool LocIsCity(uint locPid)
{
	return(locPid<=(32)||locPid==(1216)||locPid==(43)||locPid==96);
}

bool LocIsMasked(uint locPid)
{
	return(locPid==(42));
}

bool LocIsHidden(uint locPid)
{
	return false;
}                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           

shared interface FileObject
{
	string@get_DictKey();
	string@get_ObjectName()const;
	void FormatStringData(string&nameData,string&data);
	FileObject@get_Pattern(string&name)const;
	FileObject@get_Copy(string&name);
	void Prepare(); 
	
	void set_GlobalData(string@name,string@value);          
	
	string@get_GlobalData(string@name);            
	
}

shared interface AnyDataObject
{
	string@get_DictKey();
	string@get_ObjectName()const;
	uint[]@get_SaveData();
	void InitData(uint[]&data);
}

shared interface ManagerObject
{
	FileObject@get_ProtoObject(string@name);
	void ParseProtoTypes(const string&ex,const FileObject&pattern,const string@search);
	FileObject@ParseProtoTypeFile(string&name,const string&ex,const FileObject&pattern,const string@search);
	FileObject@AddPrototype(FileObject@proto);
	FileObject@StringToFileObject(string&name,string&txt,const FileObject&pattern);
}

shared interface ValueAPI{}
shared class SettingsAPI
{
	string Name;
	bool IsDebug;
} 

shared class GlobalData
{
	uint Hash;
	string Value;
	
	GlobalData(string@name)
	{
		Hash=GetStrHash(name);
		Value="";
	} 
	
	void SaveData(uint[]&outArray,uint&position)
	{
		uint len=Value.length();
		
		outArray.resize(position+2+len/2);
		
		outArray[position++]=Hash;
		outArray[position++]=len;
		
		for(uint i=0;i<len;i++)
		{
			outArray[position]|=Value[i++]<<24;
			outArray[position]|=Value[i++]<<16;
			outArray[position]|=Value[i++]<<8;
			outArray[position++]|=Value[i];
		}
	} 
	
	void LoadData(uint[]&in outArray,uint&position)
	{
		Hash=outArray[position++];
		uint len=outArray[position++];
		Value.resize(len);
		
		for(uint i=0;i<len;i++)
		{
			Value[i++]=(outArray[position]>>24)&0xFF;
			Value[i++]=(outArray[position]>>16)&0xFF;
			Value[i++]=(outArray[position]>>8)&0xFF;
			Value[i]=outArray[position++]&0xFF;
			
		}
	}
} 

shared class Hexagonal
{
	Hexagonal(){Reset();}
	Hexagonal(const uint16&in x,const uint16&in y){Set(x,y);}
	Hexagonal(const Hexagonal&master){Set(master);}
	
	Hexagonal(const Critter&master){Set(master.HexX,master.HexY);}
	Hexagonal(const Item&master){Set(master.HexX,master.HexY);}
	Hexagonal(const Scenery&master){Set(master.HexX,master.HexY);}
	
	bool Entire(Map&map,int entNum){return map.GetEntireCoords(entNum,0,X,Y);}
	bool IsPassed(Map&map){return ValidPosition(map)&&map.IsHexPassed(X,Y);}
	bool IsPassed(Map&map,Hexagonal&begin,Hexagonal&end){return ValidPosition(map,begin,end)&&map.IsHexPassed(X,Y);}
	
	bool ValidPosition(Map&map)
	{
		Hexagonal end,begin;
		if(end.Entire(map,0)&&begin.Entire(map,255))
		return ValidPosition(map,begin,end);
		return false;
	}
	
	bool ValidPosition(Map&map,Hexagonal&begin,Hexagonal&end)
	{
		return(X>=begin.X&&Y>=begin.Y
		&&X<=end.X&&Y<=end.Y);
	}
	
	bool Transit(Critter&critter,Map&map){return Transit(critter,map,critter.Dir);}
	bool Transit(Critter&critter,Map&map,uint8 direction)
	{
		if(!IsPassed(map))return false;
		return critter.TransitToMap(map.Id,X,Y,direction);
	}
	
	bool Transit(Critter&critter,uint mapId){return Transit(critter,mapId,critter.Dir);}
	bool Transit(Critter&critter,uint mapId,uint8 direction)
	{
		if(mapId==0)return false;
		Map@map=GetMap(mapId);
		if(@map is null)return false;
		return Transit(critter,map,direction);
	} 
	
	void Set(const uint16&in x,const uint16&in y){X=x;Y=y;}
	void Set(const Hexagonal&in other){Set(other.X,other.Y);}
	void Reset(){X=Y=0;}
	uint Distantion(Hexagonal&other){return GetDistantion(X,Y,other.X,other.Y);}
	
	uint16 X;
	uint16 Y;
	
	bool opEquals(const Hexagonal&in other){return(other.X==X&&other.Y==Y);}
	Hexagonal&opAssign(const Hexagonal&in other)
	{
		Set(other);
		return this;
	}
	
	const uint get_UID(const uint w)const{return X+Y*w;}
	string get_Debug(){return"X:"+X+"Y:"+Y;}
	void Log(string&str){::Log(str+":"+Debug);}
}    

shared class MapHash
{
	MapHash(const uint16&in protoId)
	{
		ProtoId=protoId;
		@Min=null;
		@Max=null;
	}
	
	MapHash&opAssign(Map&map)
	{
		@Min=Hexagonal(0,0);
		@Max=Hexagonal(0,0);
		map.GetEntireCoords(0,0,Max.X,Max.Y);
		map.GetEntireCoords((255),0,Min.X,Min.Y);
		return this;
	}
	
	uint16 ProtoId;
	Hexagonal@Min;
	Hexagonal@Max;
} 

shared class Line
{
	Line(Hexagonal&a,Hexagonal&b){@A=a;@B=b;}
	
	uint get_Length()
	{
		return B.Distantion(A);
	}
	
	uint get_Point(Hexagonal&point)
	{
		return B.Distantion(point);
	}
	
	float get_Module(Hexagonal&point)
	{
		return Point[point]/Length;
	}
	
	Hexagonal@get_opIndex(const uint&in size)
	{
		
		const float mod=float(size/Length);
		return@Hexagonal(A.X+(B.X-A.X)*mod,A.Y+(B.Y-A.Y)*mod);
	} 
	
	Line(Map&map,uint16 grid,MapHash@hash)
	{
		if(@hash is null)
		{
			Hexagonal min,max;
			map.GetTransferParams(min.X,min.Y,max.X,max.Y,grid);
			
			@A=@Hexagonal(min.X,min.Y);
			@B=@Hexagonal(max.X,max.Y);
		}
		else
		{
			if(@hash.Min is null||@hash.Max is null)
			map.GetTransferParams(hash.Min.X,hash.Min.Y,hash.Max.X,hash.Max.Y,grid);
			
			@A=@Hexagonal(hash.Min.X,hash.Min.Y);
			@B=@Hexagonal(hash.Max.X,hash.Max.Y);
		}
	} 
	
	string get_Debug(){return"A<"+A.Debug+">B<"+B.Debug+">";}
	void Log(string&str){::Log(str+":"+Debug);}
	
	Hexagonal@A;
	Hexagonal@B;
}                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               

class Entire
{
	int Number;
	uint16 HexX;
	uint16 HexY;
}

uint ParseEntires(Map&map,Entire[]&entires,int number)
{
	uint oldCount=entires.length();
	uint count=map.CountEntire(number);
	entires.resize(oldCount+count);
	
	for(uint i=0;i<count;i++)
	{
		Entire@ent=entires[oldCount+i];
		if(map.GetEntireCoords(number,i,ent.HexX,ent.HexY)==false)
		return 0;
		ent.Number=number;
	}
	
	return count;
}

bool GetEntireFreeHex(Map&map,int number,uint16&hx,uint16&hy)
{
	uint count=map.CountEntire(number); 
	
	for(uint i=0;i<count;i++)
	{
		if(map.GetEntireCoords(number,i,hx,hy)&&map.IsHexPassed(hx,hy))
		return true;
	}
	
	if(hx==0||hy==0||hx>=map.GetWidth()-1||hy>=map.GetHeight()-1)
	return false; 
	
	for(uint i=0;i<count;i++)
	{
		if(map.GetEntireCoords(number,i,hx,hy))
		{
			for(int x=-1;x<=1;x++)
			{
				for(int y=-1;y<=1;y++)
				{
					if(x==0&&y==0)
					continue;
					
					if(__MapHexagonal)
					{
						if((hx%2)==1&&((x==-1&&y==1)||(x==1&&y==1)))
						continue;
						if((hx%2)==0&&((x==-1&&y==-1)||(x==1&&y==-1)))
						continue;
					}
					
					if(map.IsHexPassed(hx+x,hy+y))
					{
						hx+=x;
						hy+=y;
						return true;
					}
				}
			}
		}
	}
	return false;
}

bool GetNearEntire(Map&map,int number,uint16&hx,uint16&hy)
{
	uint16 hxBase=hx;
	uint16 hyBase=hy;
	
	Entire[]entires;
	uint count=ParseEntires(map,entires,number);
	if(count==0)
	return false;
	
	hx=entires[0].HexX;
	hy=entires[0].HexY;
	for(uint i=1;i<count;i++)
	{
		Entire@ent=entires[i];
		if(GetDistantion(hxBase,hyBase,ent.HexX,ent.HexY)<GetDistantion(hxBase,hyBase,hx,hy))
		{
			hx=ent.HexX;
			hy=ent.HexY;
		}
	}
	
	return true;
}                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   

shared interface iManagerModule{bool manager_init();
	bool manager_start();}
shared interface iManager_loop{uint global_loop();}
shared interface iManager_critter_init{bool global_critter_init(Critter&critter,bool firstTime);}
shared interface iManager_critter_finish{bool global_critter_finish(Critter&critter,bool toDelete);}
shared interface iManager_critter_idle{bool global_critter_idle(Critter&critter);}
shared interface iManager_critter_dead{bool global_critter_dead(Critter&critter,Critter@killer);}
shared interface iManager_critter_respawn{bool global_critter_respawn(Critter&critter);}
shared interface iManager_map_critter_in{bool global_map_critter_in(Map&map,Critter&critter);}
shared interface iManager_map_critter_out{bool global_map_critter_out(Map&map,Critter&critter);}
shared interface iManager_world_save{bool global_world_save();}
shared interface iManager_player_registration{bool global_player_registration(uint ip,string&name,uint&textMsg,uint&strNum);}
shared interface iManager_player_login{bool global_player_login(uint ip,string&name,uint id,uint&textMsg,uint&strNum);}
shared interface iManager_time{bool global_time(int8 type);}

shared interface iManager_critter_use_skill{bool global_critter_use_skill(Critter&critter,int skill,Critter@targetCritter,Item@targetItem,Scenery@targetScenery);}

shared interface iManagerElement
{
	iManagerModule@GetLink();
	uint GetId();
	string&GetName();
	uint&GetEventFlags();
	int8&GetTimeChangeCall();
	uint8 GetPriority();
}                     

import iManagerElement@manager_add_module(iManagerModule@link,string&name,uint8 priority)from"manager";                                                                              

const uint8[]chances_radscorp_waste={20,35,20,5};

const uint8[]chances_gecko_forest={30,30,20,10};

const uint8[]chances_rats_forest={10,10,10,20};
const uint8[]chances_rats_ruins={30,30,50,100};
const uint8[]chances_rats_road={10,10,10,20};

const uint8[]chances_raiders_ruins={5,5,5,1};
const uint8[]chances_raiders_road={5,10,15,50};

const uint8[]chances_mirelurk={40,30,10,200};            

uint __GetColor(int r,int g,int b)
{
	r=(((r)>(255))?(255):(((r)<(0))?(0):(r)));
	g=(((g)>(255))?(255):(((g)<(0))?(0):(g)));
	b=(((b)>(255))?(255):(((b)<(0))?(0):(b)));
	return(uint((0xFF<<24)|(((r)&0xFF)<<16)|(((g)&0xFF)<<8)|((b)&0xFF)));
}

uint __GetGradient(uint colorStart,uint colorEnd,uint8 pos)
{
	pos=(((pos)>(100))?(100):(((pos)<(1))?(1):(pos)));
	
	int aS=(colorStart>>24)&0xFF,
	rS=((colorStart>>16)&0xFF),
	gS=((colorStart>>8)&0xFF),
	bS=((colorStart)&0xFF),
	
	aE=(colorEnd>>24)&0xFF,
	rE=((colorEnd>>16)&0xFF),
	gE=((colorEnd>>8)&0xFF),
	bE=((colorEnd)&0xFF); 
	
	rS=(((rE-int(rS*(pos*0.01)))>0)?(rE-int(rS*(pos*0.01))):-(rE-int(rS*(pos*0.01))));
	gS=(((gE-int(gS*(pos*0.01)))>0)?(gE-int(gS*(pos*0.01))):-(gE-int(gS*(pos*0.01))));
	bS=(((bE-int(bS*(pos*0.01)))>0)?(bE-int(bS*(pos*0.01))):-(bE-int(bS*(pos*0.01))));
	
	return __GetColor(rS,gS,bS);
}

uint __GetColor(uint8&a,uint8&r,uint8&g,uint8&b,uint color){
	a=(color>>24)&0xFF;
	r=((color>>16)&0xFF);
	g=((color>>8)&0xFF);
	b=((color)&0xFF);
	
	return 0;
}                                                            

namespace Global
{
	Kind@[]Kinds;
	World World;
}

namespace Kind
{
	enum Data
	{
		CurrentLife,
		TimeEvent,
		TimeEventIndex,
		Length,
		DefaultValue=0
	}
	
	enum Hierarchy
	{
		None,
		Queen,
		Mob
	}
}

namespace Result
{
	enum Transit
	{
		CellNotFound=-4,
		NotHiddenContent,
		MapNotFound,
		FailGenerated,
		Okay,
		MapGenerated,
	}
}

namespace Imports
{
	import uint GetGlobalMapRelief(uint x,uint y)from"worldmap";
	import void SpawnItemCell(Map&map)from"local_population";
	import void InjureCritter(Critter&critter,uint dmg,uint dmgType,uint8 dir,uint attackerId)from"combat";
} 

ManagerObject@get_objectManager(){return@Global::World;}

bool IsKindFriend(Critter&critter,Critter&check)
{
	if(critter.KindHierarchy!=Kind::Hierarchy::None&&Kind::Hierarchy::None!=check.KindHierarchy&&critter.KindIndex<Global::Kinds.length())
	{
		Kind@kind=@Global::Kinds[critter.KindIndex],checkKind=@Global::Kinds[check.KindIndex];
		for(uint i=0,iEnd=kind.Friends.length();i<iEnd;i++)
		{
			if(@kind.Friends[i]is@checkKind)
			return true;
		}
	}
	return false;
} 

interface Reference{Reference@GetThis();}

MapHash@GetMapHash(const uint16&in protoId)
{
	if(Global::World.HashMaps.length()<=protoId)
	Global::World.HashMaps.resize(protoId+1);
	else if(@Global::World.HashMaps[protoId]!is null)
	return@Global::World.HashMaps[protoId];
	
	MapHash hash(protoId);
	@Global::World.HashMaps[protoId]=hash;
	return hash;
}

class HierarchyLink
{
	HierarchyLink(string@name,int value)
	{
		Name=name;
		Value=value;
	}
	
	string Name;
	int Value;
}

class Hierarchy:FileObject
{
	string Name;
	HierarchyLink@[]Links;
	
	void Prepare()override{}
	string@get_DictKey()override{return Name;}
	string@get_ObjectName()const override{return"Hierarchy";}
	FileObject@get_Pattern(string&name)const override{return Hierarchy(name);}
	FileObject@get_Copy(string&name)override
	{
		Hierarchy@copy=@Hierarchy(name);
		
		copy.Links.resize(this.Links.length());
		for(uint i=0,iEnd=this.Links.length();i<iEnd;i++)
		@copy.Links[i]=this.Links[i];
		return copy;
	}
	
	void set_GlobalData(string@name,string@value)override
	
	{
		const uint hash=GetStrHash(name);
		for(uint i=0,iEnd=GlobalDataList.length();i<iEnd;i++)
		if(GlobalDataList[i].Hash==hash)
		{
			GlobalDataList[i].Value=value;
			return;
		}
	}
	
	string@get_GlobalData(string@name)override
	
	{
		const uint hash=GetStrHash(name);
		for(uint i=0,iEnd=GlobalDataList.length();i<iEnd;i++)
		if(GlobalDataList[i].Hash==hash)
		return GlobalDataList[i].Value;
		return null;
	}
	
	private GlobalData@[]GlobalDataList;
	
	void FormatStringData(string&nameData,string&data)override
	{
		string@[]args=splitEx(nameData,":");
		if(args.length()>=1)
		{
			if(args.length()==1)
			{
				if(nameData=="GlobalData")
				{
					string@[]globals=splitEx(data," ");
					for(uint i=0,iEnd=globals.length();i<iEnd;i++)
					GlobalDataList.insertLast(GlobalData(globals[i]));
				}
				else
				{
					int mem=0;
					if(data[0]==32)
					{
						string@[]check=splitEx(data," ");
						data=join(check,"");
					}
					StrToInt(data,mem);
					Links.insertLast(HierarchyLink(nameData,mem));
				}
			}
		}
	}
	
	Hierarchy(string@name){Name=name;GlobalDataList.resize(0);}
}

class ProtoSettings:SettingsAPI,FileObject
{
	bool KindSpawnLogging;
	
	string@get_DictKey()override{return Name;}
	string@get_ObjectName()const override{return"Settings";}
	FileObject@get_Pattern(string&name)const override{return ProtoSettings(name);}
	FileObject@get_Copy(string&name)override
	{
		ProtoSettings@copy=@ProtoSettings(name);
		return copy;
	}
	
	void set_GlobalData(string@name,string@value)override
	
	{
		const uint hash=GetStrHash(name);
		for(uint i=0,iEnd=GlobalDataList.length();i<iEnd;i++)
		if(GlobalDataList[i].Hash==hash)
		{
			GlobalDataList[i].Value=value;
			return;
		}
	}
	
	string@get_GlobalData(string@name)override
	
	{
		const uint hash=GetStrHash(name);
		for(uint i=0,iEnd=GlobalDataList.length();i<iEnd;i++)
		if(GlobalDataList[i].Hash==hash)
		return GlobalDataList[i].Value;
		return null;
	}
	
	void Prepare()override{}
	
	private GlobalData@[]GlobalDataList;
	
	void FormatStringData(string&nameData,string&data)override
	{
		string@[]args=splitEx(nameData,":");
		if(args.length()>=1)
		{
			if(args.length()==1)
			{
				if(nameData=="Flags")
				{
					string@[]params=splitEx(data," ");
					for(uint i=0,iEnd=params.length();i<iEnd;i++)
					{
						if(params[i]=="Debug")IsDebug=true;
						else if(params[i]=="Default")@Global::World.Settings=this;
						else if(params[i]=="KindSpawnLogging")KindSpawnLogging=true;
					}
				}
				else if(nameData=="GlobalData")
				{
					string@[]globals=splitEx(data," ");
					for(uint i=0,iEnd=globals.length();i<iEnd;i++)
					GlobalDataList.insertLast(GlobalData(globals[i]));
				}
			}
		}
	}
	
	ProtoSettings(string@name)
	{
		Name=name;
		IsDebug=KindSpawnLogging=false;
		GlobalDataList.resize(0);
	}
}

class KindReferenceHash:Reference
{
	KindReferenceHash(const string&in name){
		Name=name;
	}
	
	Reference@GetThis()override{
		return cast<Reference@>(@Global::World.ProtoObject["Kind:"+Name]);
	}
	
	string Name;
} 

funcdef void SpawnObjectProtoFuncdef(Critter@,Kind@,uint16,SpawnHash@);

void SetQueen(Critter@critter,Kind@kind,uint16 spawnIndex,SpawnHash@hash)
{
	if(@critter!is null)
	{
		critter.KindHierarchy=Kind::Hierarchy::Queen;
		critter.KindIndex=kind.Data[Kind::Data::TimeEventIndex];
		critter.KindQIndex=spawnIndex;
		critter.AIGroupHierarchy=critter.Id;
		hash.HashData.set("AIGroupHierarchy",critter.AIGroupHierarchy);
		critter.AIWorkRadius=kind.SpawnRadius.Max;
	}
}

void DefaultSpawnMob(Critter@critter,Kind@kind,uint16 spawnIndex,SpawnHash@hash)
{
	if(@critter!is null)
	{
		critter.KindHierarchy=Kind::Hierarchy::Mob;
		critter.KindIndex=kind.Data[Kind::Data::TimeEventIndex];
		critter.KindQIndex=spawnIndex;
		if(hash.HashData.exists("AIGroupHierarchy"))
		hash.HashData.get("AIGroupHierarchy",critter.AIGroupHierarchy);
		else ClearLog("Ошибка спавндаты");
		critter.AIWorkRadius=kind.SpawnRadius.Max;
	}
}

class Kind:FileObject,AnyDataObject,Reference
{
	uint[]@get_SaveData()override{
		return Data;
	}
	
	Reference@GetThis()override{
		return@this;
	}
	
	void Prepare()override{}
	
	void set_GlobalData(string@name,string@value)override
	
	{
		const uint hash=GetStrHash(name);
		for(uint i=0,iEnd=GlobalDataList.length();i<iEnd;i++)
		if(GlobalDataList[i].Hash==hash)
		{
			GlobalDataList[i].Value=value;
			return;
		}
	}
	
	string@get_GlobalData(string@name)override
	
	{
		const uint hash=GetStrHash(name);
		for(uint i=0,iEnd=GlobalDataList.length();i<iEnd;i++)
		if(GlobalDataList[i].Hash==hash)
		return GlobalDataList[i].Value;
		return null;
	}
	
	private GlobalData@[]GlobalDataList;
	
	void InitData(uint[]&data)override
	{
		Data=data; 
		
		if(Data[Kind::Data::TimeEvent]==0)
		Data[Kind::Data::TimeEvent]=__FullSecond+((TimeMinute.Random)*__TimeMultiplier*60);
		Data[Kind::Data::TimeEventIndex]=Global::Kinds.length();
		CreateTimeEvent(Data[Kind::Data::TimeEvent],"e_CreateKinds",Data[Kind::Data::TimeEventIndex],false);
		Global::Kinds.insertLast(@this);
		
		for(uint i=0;i++<Data[Kind::Data::CurrentLife];)
		if(!AddLife())Data[Kind::Data::CurrentLife]--;
		
		InitReferenceListing(Friends);
		InitReferenceListing(Enemies);
		
		Spawn();
	}
	
	void InitReferenceListing(Reference@[]@refList)
	{
		for(uint i=0,iEnd=refList.length();i<iEnd;i++)
		@refList[i]=@refList[i].GetThis();
		
		for(uint i0=0,iEnd=refList.length();i0<iEnd;i0++)
		{
			if(@refList[i0]is null)
			{
				iEnd--;
				refList.removeAt(i0--);
				continue;
			}
			
			for(uint i1=i0+1;i1<iEnd;i1++)
			{
				if(@refList[i0]is@refList[i1])
				{
					iEnd--;
					refList.removeAt(i0--);
					break;
				}
			}
		}
	}
	
	Kind(string&name)
	{
		ThisIsDebug=ThisSpawnLogging=false;
		Name=name;
		AiScript="Ai@Default";
		Data.resize(Kind::Data::Length);
		Friends.resize(0);
		for(uint i=0;i<uint(Kind::Data::Length);i++)
		Data[i]=Kind::Data::DefaultValue;
		GlobalDataList.resize(0);
	}
	
	void Kill(Cell@cell)
	{
		if(@cell!is null)
		{
			cell.Biom.FreeCell(@cell);
			Data[Kind::Data::CurrentLife]--;
		}
	}
	
	string@get_DictKey()override{return Name;}
	string@get_ObjectName()const override{return"Kind";}
	
	bool GetParamValue(string@name,int&out value){return GetConstantValue((0),@name,value);}
	bool GetConstantValue(const int&in collection,string@name,int&out value)
	{
		value=::GetConstantValue(collection,name);
		return(value!=-1);
	}
	
	void FormatStringData(string&nameData,string&data)override
	{
		string@[]args=splitEx(nameData,":");
		if(args.length()>=1)
		{
			nameData=args[0];
			if(args.length()==2)
			{
				if(nameData=="Param")
				AddParam(args[1],data,Params);
				else if(nameData=="UnityParam")
				AddParam(args[1],data,UnityParams);
			}
			else
			{
				if(nameData=="Bioms")
				{
					string@[]value=splitEx(data," ");
					
					for(uint i=0,iEnd=value.length();i<iEnd;i++)
					{
						ProtoBiom@biom=@Global::World.GetProtoBiom(value[i]);
						if(@biom!is null)
						KindBioms.insertLast(biom);
					}
				}
				else if(nameData=="GlobalData")
				{
					string@[]globals=splitEx(data," ");
					for(uint i=0,iEnd=globals.length();i<iEnd;i++)
					GlobalDataList.insertLast(GlobalData(globals[i]));
				}
				else if(nameData=="Pids")
				{
					AddObjectProto(data,Pids);
				}
				else if(nameData=="Queens")
				{
					AddObjectProto(data,Queens);
				}
				else if(nameData=="CountGroups")
				{
					CountGroups.Set(data);
				}
				else if(nameData=="Count")
				{
					CountWorld.Set(data);
				}
				else if(nameData=="TimeMinute")
				{
					TimeMinute.Set(data);
				}
				else if(nameData=="Zone")
				{
					string@[]zones=splitEx(data," ");
					for(uint i=0,iEnd=zones.length();i<iEnd;i++)
					{
						FileObject@object=Global::World.ProtoObject["Zone:"+zones[i]];
						if(@object is null)
						{
							Log("Зона <"+zones[i]+"> не найдена.");
							continue;
						}
						Zone@zone=cast<Zone@>(@object);
						if(@zone is null)
						{
							Log("Объект <"+zones[i]+"> не является зоной, ошибка данных.");
							continue;
						}
						ZoneList.insertLast(@zone);
					}
				}
				else if(nameData=="SpawnRadius")
				{
					SpawnRadius.Set(data);
				}
				else if(nameData=="AiScript")
				{
					string module="Ai";
					string function="Default";
					
					string@[]value=splitEx(data," ");
					if(value.length()==1)
					{
						function=value[0];
					}
					else if(value.length()==2)
					{
						function=value[1];
						module=value[0];
					}
					
					AiScript=module+"@"+function;
				}
				else if(nameData=="Friends")
				{
					AddReference(data,Friends);
				}
				else if(nameData=="Enemies")
				{
					AddReference(data,Enemies);
				}
				else if(nameData=="Flags")
				{
					string@[]params=splitEx(data," ");
					for(uint i=0,iEnd=params.length();i<iEnd;i++)
					{
						if(params[i]=="Debug")ThisIsDebug=true;
						else if(params[i]=="SpawnLogging")ThisSpawnLogging=true;
					}
				}
				else if(nameData=="Hierarchy")
				{
					if(data[0]==32)
					{
						string@[]check=splitEx(data," ");
						data=join(check,"");
					}
					
					@Hierarchy=cast<Hierarchy@>(@Global::World.ProtoObject["Hierarchy:"+data]);
				}
				else Log("Неопознанные данные "+nameData);
			}
		}
	}
	
	void AddReference(string&data,Reference@[]@referenceList)
	{
		string@[]value=splitEx(data," ");
		
		for(uint i=0,iEnd=value.length();i<iEnd;i++)
		referenceList.insertLast(KindReferenceHash(value[i]));
	}
	
	void AddObjectProto(string&data,ObjectValue@[]&array)
	{
		string@[]value=splitEx(data," ");
		
		for(uint i=0,iEnd=value.length();i<iEnd;i++)
		{
			int protoId=0;
			CountValue count;
			
			string@[]countStr=splitEx(value[i],":");
			if(countStr.length()==2)
			count.Set(countStr[1]);
			StrToInt(countStr[0],protoId);
			array.insertLast(ObjectValue(protoId,count,this));
		}
	}
	
	FileObject@get_Pattern(string&name)const override
	{
		return@Kind(name);
	}
	
	FileObject@get_Copy(string&name)override
	{
		Kind@copy=@Kind(name);
		
		copy.KindBioms.resize(this.KindBioms.length());
		for(uint i=0,iEnd=this.KindBioms.length();i<iEnd;i++)
		@copy.KindBioms[i]=this.KindBioms[i];
		
		@copy.Hierarchy=this.Hierarchy;
		
		copy.Queens.resize(this.Queens.length());
		for(uint i=0,iEnd=this.Queens.length();i<iEnd;i++)
		@copy.Queens[i]=this.Queens[i];
		
		copy.Pids.resize(this.Pids.length());
		for(uint i=0,iEnd=this.Pids.length();i<iEnd;i++)
		@copy.Pids[i]=this.Pids[i];
		
		copy.CountWorld=this.CountWorld;
		copy.CountGroups=this.CountGroups;
		copy.TimeMinute=this.TimeMinute;
		copy.SpawnRadius=this.SpawnRadius;
		copy.AiScript=this.AiScript;
		
		copy.UnityParams.resize(this.UnityParams.length());
		for(uint i=0,iEnd=this.UnityParams.length();i<iEnd;i++)
		@copy.UnityParams[i]=this.UnityParams[i];
		
		copy.Params.resize(this.Params.length());
		for(uint i=0,iEnd=this.Params.length();i<iEnd;i++)
		@copy.Params[i]=this.Params[i];
		
		copy.Friends.resize(this.Friends.length());
		for(uint i=0,iEnd=this.Friends.length();i<iEnd;i++)
		@copy.Friends[i]=this.Friends[i];
		
		copy.Enemies.resize(this.Enemies.length());
		for(uint i=0,iEnd=this.Enemies.length();i<iEnd;i++)
		@copy.Enemies[i]=this.Enemies[i];
		
		return@copy;
	}
	
	bool AddLife(ProtoBiom@biom)
	{
		Cell@cell=null;
		uint tick=GetTick();
		do
		{
			if(GetTick()-tick>50)
			{
				if(SpawnLogging)
				Log("Пойск свободной клетки затянулся, сворачиваем.");
				return false;
			}
			Zone@zone=null;
			if(ZoneList.length()!=0)
			@zone=ZoneList[Random(0,ZoneList.length()-1)];
			@cell=biom.RandomFreeCell[@zone];
			if(@cell!is null)
			{
				if(cell.Content.Info.Flags.Static)
				{
					if(SpawnLogging)
					Log("Статик клетка <"+cell.Content.Info.Name+">, убираем с списка свободных.");
					@cell=null;
				}
				else if(@cell.Content.CurrentKind!is null)
				{
					if(SpawnLogging)
					Log("Клетка уже заселена, убираем с списка свободных.");
					@cell=null;
				}
			}
		}
		while(@cell is null&&biom.CountFreeCells>0);
		if(@cell!is null)
		{
			if(SpawnLogging)
			Log("Семейство создано по координатам "+cell.Position.X+" "+cell.Position.Y+" Биом: <"+biom.Name+">");
			@cell.Content.CurrentKind=@this;
			return true;
		}
		
		if(SpawnLogging)
		Log("Клетка не найдена.");
		return false;
	}
	
	bool AddLife()
	{
		ProtoBiom@biom=@FreeBiom;
		if(@biom!is null)
		return AddLife(@biom);
		if(SpawnLogging)
		Log("Не найден свободный биом.");
		return false;
	}
	
	void Spawn()
	{
		const int count=CountWorld.Random;
		for(int i=Data[Kind::Data::CurrentLife];i<count;i++)
		{
			if(AddLife())
			Data[Kind::Data::CurrentLife]++;
			else
			{
				if(SpawnLogging)
				Log("Ошибка спавна.");
			}
		}
	}
	
	void SpawnSomeMobs(SpawnHash&hash,Hexagonal&in hex,int[]&in params,uint count)
	{
		const uint max=Pids.length()-1;
		for(uint i=0;i<count;i++)
		Pids[Random(0,max)].Spawn(hash,hex,SpawnRadius.Random,AiScript,GetParams(params,Params),@DefaultSpawnMob);
	} 
	
	void SpawnMobs(SpawnHash&hash,Hexagonal&in hex,int[]&in params)
	{
		const uint count=Pids.length();
		for(uint i=0;i<count;i++)
		Pids[i].Spawn(hash,hex,SpawnRadius.Random,AiScript,GetParams(params,Params),@DefaultSpawnMob);
	}
	
	int[]@GetParams(int[]&in paramsin,ParamValue@[]&params)
	{
		for(uint i=0,iEnd=params.length();i<iEnd;i++)
		params[i].Get(paramsin);
		return paramsin;
	}
	
	void AddParam(string&param,string&count,ParamValue@[]&array)
	{
		int paramNum=-1;
		if(GetParamValue(param,paramNum))
		array.insertLast(ParamValue(paramNum,count));
	}
	
	ProtoBiom@get_FreeBiom()
	{
		if(KindBioms.length()==0)
		return null;
		ProtoBiom@biom=@KindBioms[Random(0,KindBioms.length()-1)];
		if(biom.CountFreeCells==0)
		{
			ProtoBiom@[]bioms=KindBioms;
			RemoveBiom(bioms,@biom);
			while(bioms.length()!=0)
			{
				@biom=@bioms[Random(0,bioms.length()-1)];
				if(biom.CountFreeCells!=0)
				return@biom;
				RemoveBiom(bioms,@biom);
			}
			return null;
		}
		
		return@biom;
	}
	
	void RemoveBiom(ProtoBiom@[]&bioms,ProtoBiom@biom)
	{
		for(uint index=0,iEnd=bioms.length();index<iEnd;index++)
		if(@bioms[index]==@biom)
		{
			bioms.removeAt(index);
			return;
		}
	}
	
	void Log(string&log){
		::ClearLog("<"+Name+"> : "+log);
	}
	
	ProtoBiom@[]KindBioms;
	Hierarchy@Hierarchy;
	
	ObjectValue@[]Queens;
	ObjectValue@[]Pids;
	
	CountValue CountWorld;
	CountValue CountGroups;
	
	string Name;
	CountValue TimeMinute;
	
	CountValue SpawnRadius;
	string AiScript;
	
	uint[]Data;
	
	Zone@[]ZoneList;
	
	ParamValue@[]UnityParams;
	ParamValue@[]Params;
	
	Reference@[]Friends;
	Reference@[]Enemies; 
	
	bool ThisIsDebug;
	bool ThisSpawnLogging;
	
	bool get_SpawnLogging()
	{
		return ThisSpawnLogging||Global::World.Settings.KindSpawnLogging||IsDebug;
	}
	
	bool get_IsDebug()
	{
		return ThisIsDebug||Global::World.Settings.IsDebug;
	}
}

class KindInstance
{
	Kind@Proto;
	uint[]LifeQueen;
	ObjectValue@[]Queens;
	Cell@MyCell;
	
	KindInstance(Kind&kind,Cell@cell)
	{
		@Proto=kind;
		@MyCell=cell;
		
		const uint count=kind.CountGroups.Random;
		LifeQueen.resize(count);
		Queens.resize(count);
		for(uint i=0;i<count;i++)
		{
			ObjectValue@proto=Proto.Queens[Random(0,Proto.Queens.length()-1)];
			@Queens[i]=proto;
			LifeQueen[i]=proto.Count.Random;
		}
	}
	
	KindInstance(Kind&kind,uint count)
	{
		@Proto=kind;
		@MyCell=null;
		
		LifeQueen.resize(count);
		Queens.resize(count);
		for(uint i=0;i<count;i++)
		{
			ObjectValue@proto=Proto.Queens[Random(0,Proto.Queens.length()-1)];
			@Queens[i]=proto;
			LifeQueen[i]=proto.Count.Random;
		}
	}
	
	void DeadQueen(Critter&queen,CellContent&content)
	{
		if(queen.KindHierarchy==Kind::Hierarchy::Queen)
		{
			LifeQueen[queen.KindQIndex]--;
			const uint count=LifeQueen.length();
			for(uint i=0;i<count;i++)
			if(LifeQueen[i]!=0)
			return;
			
			@content.CurrentKind=null;
		}
	}
	
	~KindInstance(){
		Kill();
	}
	
	void Kill()
	{
		if(@Proto!is null)
		{
			Proto.Kill(MyCell);
			@Proto=null;
		}
	}
	
	ParamValue@[]UnityParams;
	ParamValue@[]Params;
	
	void Spawn(Map&map)
	{
		MapHash@hash=Global::World.GetHash(map);
		SpawnHash spawnHash(map);
		const int count=LifeQueen.length();
		
		int[]unityParams={};
		unityParams=Proto.GetParams(unityParams,Proto.UnityParams);
		for(int i=0;i<count;i++)
		{
			Hexagonal hex(Random(hash.Min.X,hash.Max.X),Random(hash.Min.Y,hash.Max.Y));
			Queens[i].Spawn(spawnHash,hex,Proto.SpawnRadius.Random,Proto.AiScript,LifeQueen[i],Proto.GetParams(unityParams,Proto.Params),@SetQueen);
			Proto.SpawnMobs(spawnHash,hex,unityParams);
		}
	}
	
	void Spawn(Map&map,Hexagonal@[]&hexs)
	{
		MapHash@hash=Global::World.GetHash(map);
		SpawnHash spawnHash(map);
		if(hexs.length()>LifeQueen.length())
		{
			Log("Error, invalid count groups");
			hexs.resize(LifeQueen.length());
		}
		
		const int count=hexs.length();
		int[]unityParams={};
		unityParams=Proto.GetParams(unityParams,Proto.UnityParams);
		for(int i=0;i<count;i++)
		{
			Hexagonal@hex=hexs[i];
			Queens[i].Spawn(spawnHash,hex,Proto.SpawnRadius.Random,Proto.AiScript,LifeQueen[i],Proto.GetParams(unityParams,Proto.Params),@SetQueen);
			Proto.SpawnMobs(spawnHash,hex,unityParams);
		}
	}
	
	void Spawn(Map&map,Hexagonal@[]&hexs,uint16 countMobs)
	{
		MapHash@hash=Global::World.GetHash(map);
		SpawnHash spawnHash(map);
		if(hexs.length()>LifeQueen.length())
		{
			Log("Error, invalid count groups");
			hexs.resize(LifeQueen.length());
		}
		
		const int count=hexs.length();
		int[]unityParams={};
		unityParams=Proto.GetParams(unityParams,Proto.UnityParams);
		for(int i=0;i<count;i++)
		{
			Hexagonal@hex=hexs[i];
			Queens[i].Spawn(spawnHash,hex,Proto.SpawnRadius.Random,Proto.AiScript,LifeQueen[i],Proto.GetParams(unityParams,Proto.Params),@SetQueen);
			Proto.SpawnSomeMobs(spawnHash,hex,unityParams,countMobs);
		}
	}
}

class SpawnHash
{
	uint[]UIDs;
	Map@Map;
	uint Width;
	
	dictionary HashData;
	
	SpawnHash(Map&map)
	{
		@this.Map=map;
		Width=map.GetWidth();
	}
	
	bool ReserveHex(Hexagonal&hex,Hexagonal&hexCheck,Hexagonal@[]&hexs,const uint&radius)
	{
		if(IsFreeHex(hex,hexCheck,radius))
		{
			hexs.insertLast(hexCheck);
			UIDs.insertLast(hexCheck.UID[Width]);
			return true;
		}
		return false;
	}
	
	bool IsFreeHex(Hexagonal&hex,Hexagonal&hexCheck,const uint&radius)
	{
		if(UIDs.find(hexCheck.UID[Width])==-1)
		{
			uint length=this.Map.GetPathLength(hex.X,hex.Y,hexCheck.X,hexCheck.Y,0);
			return(hex==hexCheck||(length!=0&&length<=radius));
		}
		return false;
	}
}

uint e_CreateKinds(uint[]@values)
{
	if(@values is null||values[0]==uint(-1))
	return 0;
	
	Kind@kind=Global::Kinds[values[0]];
	if(@kind is null)
	{
		Log("Что-то пошло не так, семейства не будут созданы.");
		return 0;
	}
	kind.Spawn();
	kind.Data[Kind::Data::TimeEvent]+=((kind.TimeMinute.Random)*__TimeMultiplier*60);
	return((kind.TimeMinute.Random)*__TimeMultiplier*60);
}

class ObjectValue:ValueAPI
{
	ObjectValue(uint16 protoId,CountValue count,Kind@kind)
	{
		ProtoId=protoId;
		Count=count;
		@BaseKind=@kind;
	}
	
	void Spawn(SpawnHash&hash,Hexagonal&hex,uint radius,string@script,int[]params,SpawnObjectProtoFuncdef@function)
	{
		uint count=Count.Random;
		Spawn(hash,hex,radius,script,count,params,function);
	}
	
	void Spawn(SpawnHash&hash,Hexagonal&hex,uint radius,string@script,uint&count,int[]params,SpawnObjectProtoFuncdef@function)
	{
		Hexagonal@[]hexs;
		
		for(uint i=0;i<count;i++)
		{
			uint try=10;
			while(try--!=0)
			if(hash.ReserveHex(hex,Hexagonal(hex.X+Random(0-radius,radius),hex.Y+Random(0-radius,radius)),hexs,radius))
			break;
		}
		
		count=hexs.length();
		for(uint i=0;i<count;i++)
		{
			if(@function is null)
			hash.Map.AddNpc(ProtoId,hexs[i].X,hexs[i].Y,0,params,null,script);
			else
			function(@hash.Map.AddNpc(ProtoId,hexs[i].X,hexs[i].Y,0,params,null,script),@BaseKind,i,hash);
		}
	}
	
	Kind@BaseKind;
	uint16 ProtoId;
	CountValue Count;
}

class ParamValue:ValueAPI
{
	ParamValue(int param,string&count)
	{
		Param=param;
		Value.Set(count);
	}
	
	void Get(int[]&params)
	{
		params.insertLast(Param);
		params.insertLast(Value.Random);
	}
	
	int Param;
	CountValue Value;
}

class CountValue:ValueAPI
{
	CountValue(){Min=Max=1;}
	CountValue(::string&data){Set(data);}
	
	void Set(::string&data)
	{
		::string@[]str=splitEx(data,"-");
		if(str.length()>0)
		{
			if(str.length()==2)
			{
				::StrToInt(str[0],Min);
				::StrToInt(str[1],Max);
			}
			else if(str.length()==1)
			{
				::StrToInt(str[0],Min);
				Max=Min;
			}
		}
		else Min=Max=0;
	}
	
	void Set(int value)
	{
		Min=Max=value;
	}
	
	int Min;
	int Max;
	
	int get_Random(){return Random(Min,Max);}
}

class MapPacket
{
	MapPacket(string&name)
	{
		MapsLastIndex=-1;
		Name=name;
	}
	
	private MapHash@[]Maps;
	private int MapsLastIndex;
	string Name;
	
	const int get_End()const{return MapsLastIndex;}
	
	const uint16 get_MapPid()const
	{
		if(MapsLastIndex==-1)
		return 0;
		
		MapHash@hash=@Maps[Random(0,MapsLastIndex)];
		
		if(@hash is null)
		{
			Log("WTF? Не валиден хэш карты "+MapsLastIndex+" "+Maps.length());
			for(uint i=0;i<Maps.length();i++)
			Log("i<"+i+"> "+(@Maps[i]!is null));
		}
		
		return hash.ProtoId;
	}
	
	const uint16 opIndex(uint index)const
	{
		return(int(index)<=MapsLastIndex)
		?Maps[index].ProtoId
		:0;
	}
	
	uint16 opAddAssign(const uint16&in protoId)
	{
		MapsLastIndex=Maps.length();
		Maps.insertLast(@Global::World.Hash[protoId]);
		return protoId;
	}
	
	uint16 opAddAssign(string&in protoId)
	{
		int temp=-1;
		StrToInt(protoId,temp);
		if(temp>0)
		return opAddAssign(temp);
		return 0;
	}
	
	bool IsProtoId(uint16 protoId)
	{
		for(uint i=0;i<=uint(MapsLastIndex);i++)
		if(protoId==Maps[i].ProtoId)
		return true;
		return false;
	}
}

class BiomConversion
{
	string IfBiom;
	string ToConvert;
	
	BiomConversion(string&ifbiom,string&tobiom)
	{
		IfBiom=ifbiom;
		ToConvert=tobiom;
	}
	
	bool opEquals(const ProtoBiom&biom){return(IfBiom==biom.Name);}
}

class ProtoBiomReference:Reference
{
	ProtoBiomReference(const string&in name){
		Name=name;
	}
	
	Reference@GetThis()override{
		return cast<Reference@>(@Global::World.GetProtoBiom(Name));
	}
	
	string Name;
}

class ProtoBiom:FileObject,Reference
{
	string Name;
	string ParseSymbol;
	string@ClientSymbol;
	
	uint ColorSymbol;
	uint ColorCell;
	
	float Speed;
	
	BiomConversion@[]ConversionsData;
	MapPacket@Default;
	
	dictionary MapPackets;
	
	private Cell@[]Cells;
	private Cell@[]FreeCells;
	
	Reference@[]Mimic;
	BiomFlags Flags;
	
	Reference@GetThis()override{
		return@this;
	}
	
	void AddReference(string&data,Reference@[]@referenceList)
	{
		string@[]value=splitEx(data," ");
		
		for(uint i=0,iEnd=value.length();i<iEnd;i++)
		referenceList.insertLast(ProtoBiomReference(value[i]));
	} 
	
	void Prepare()override{}
	
	void set_GlobalData(string@name,string@value)override
	
	{
		const uint hash=GetStrHash(name);
		for(uint i=0,iEnd=GlobalDataList.length();i<iEnd;i++)
		if(GlobalDataList[i].Hash==hash)
		{
			GlobalDataList[i].Value=value;
			return;
		}
	}
	
	string@get_GlobalData(string@name)override
	
	{
		const uint hash=GetStrHash(name);
		for(uint i=0,iEnd=GlobalDataList.length();i<iEnd;i++)
		if(GlobalDataList[i].Hash==hash)
		return GlobalDataList[i].Value;
		return null;
	}
	
	private GlobalData@[]GlobalDataList;
	
	void EraseCell(Cell@cell)
	{
		for(uint i=0,iEnd=Cells.length();i<iEnd;i++)
		{
			if(@Cells[i]is@cell)
			{
				Cells.removeAt(i);
				break;
			}
		}
		for(uint i=0,iEnd=FreeCells.length();i<iEnd;i++)
		{
			if(@FreeCells[i]is@cell)
			{
				FreeCells.removeAt(i);
				break;
			}
		}
	}
	
	void AddBiom(Cell@cell)
	{
		Cells.insertLast(@cell);
		FreeCells.insertLast(@cell);
	}
	
	Cell@get_RandomFreeCell(Zone@zone)
	{
		if(CountFreeCells==0)
		return null;
		uint index=Random(0,CountFreeCells-1);
		Cell@ret=@FreeCells[index];
		if(@zone!is null&&@ret!is null&&zone!=ret)
		return null;
		FreeCells.removeAt(index);
		return@ret;
	}
	
	uint get_CountFreeCells()
	{
		return FreeCells.length();
	}
	
	void FreeCell(Cell@cell)
	{
		FreeCells.insertLast(@cell);
	}
	
	ProtoBiom(string&name)
	{
		Name=name;
		ParseSymbol=substring(name,0,1);
		@Default=null;
		@ClientSymbol=null;
		Speed=1.0f;
		ColorCell=0;
		GlobalDataList.resize(0);
		Flags=false;
	}
	
	const uint16 get_DefaultMapPid()
	{
		return Default.MapPid;
	}
	
	MapPacket@FormatMapPacket(MapPacket&packet,string&data)
	{
		string@[]args=splitEx(data," ");
		for(uint i=0,iEnd=args.length();i<iEnd;i++)
		{
			string@[]args2=splitEx(args[i],"-");
			if(args2.length()==2)
			{
				int temp0=-1,temp1=-1;
				StrToInt(args2[0],temp0);
				StrToInt(args2[1],temp1);
				
				for(temp1++;temp0<temp1;temp0++)
				packet+=temp0;
			}
			else
			packet+=args[i];
		}
		return@packet;
	}
	
	private void ReloadDefaultMaps()
	{
		@Default=MapPacket(Name+":Default");
	}
	
	uint FormatColor(const string&data)
	{
		uint8 colorCount=0;
		uint8[]colors={};
		int buffer=0;
		::string@[]colorsStr=::splitEx(data," ");
		for(uint i=0,iEnd=colorsStr.length();i<iEnd;i++)
		{
			if(::StrToInt(colorsStr[i],buffer))
			if(colorCount++<4)
			colors.insertLast(uint8(buffer));
		}
		
		if(colorCount>=3)
		{
			if(colorCount==4)
			return(((((uint((0xFF<<24)|(((colors[0])&0xFF)<<16)|(((colors[1])&0xFF)<<8)|((colors[2])&0xFF))))|0xFF000000)^0xFF000000)|((colors[3])&0xFF)<<24);
			else return(uint((0xFF<<24)|(((colors[0])&0xFF)<<16)|(((colors[1])&0xFF)<<8)|((colors[2])&0xFF)));
		}
		return 0;
	}
	
	FileObject@get_Pattern(string&name)const override{return@ProtoBiom(name);}
	FileObject@get_Copy(string&name)override
	{
		ProtoBiom@copy=@ProtoBiom(name);
		copy.Flags=this.Flags;
		return copy;
	}
	
	string@get_DictKey()override{return ParseSymbol;}
	string@get_ObjectName()const override{return"ProtoBiom";}
	
	void FormatStringData(string&nameData,string&data)override
	override
	{
		string@[]args=splitEx(nameData,":");
		if(args.length()>=1&&args[0]=="Maps")
		{
			if(args.length()==1||args[1]=="Default")
			{
				if(@Default is null)
				ReloadDefaultMaps();
				FormatMapPacket(Default,data);
			}
			else if(args.length()==2)
			{
				MapPacket@maps=@FormatMapPacket(MapPacket(Name+":"+args[1]),data);
				if(@Default is null)
				@Default=@maps;
				Flags.Direction=true;
				MapPackets.set(args[1],@maps);
			}
		}
		else if(args.length()==2)
		{
			if(args[0]=="Symbol")
			{
				if(args[1]=="Parse")
				{
					if(data.length()!=1)
					{
						string@[]check=splitEx(data," ");
						data=join(check,"");
					}
					
					ParseSymbol=data;
				}
				else if(args[1]=="Color")
				{
					ColorSymbol=FormatColor(data);
				}
				else if(args[1]=="Client")
				{
					if(data.length()!=1)
					{
						string@[]check=splitEx(data," ");
						data=join(check,"");
					}
					
					@ClientSymbol="";
					ClientSymbol=data;
				}
			}
			else if(args[0]=="Cell")
			{
				if(args[1]=="Color")
				{
					ColorCell=FormatColor(data);
				}
			}
			else if(args[0]=="Conversion")
			{
				if(data[0]==32)
				{
					string@[]check=splitEx(data," ");
					data=join(check,"");
				}
				ConversionsData.insertLast(@BiomConversion(args[1],data));
			}
		}
		else if(nameData=="GlobalData")
		{
			string@[]globals=splitEx(data," ");
			for(uint i=0,iEnd=globals.length();i<iEnd;i++)
			GlobalDataList.insertLast(GlobalData(globals[i]));
		}
		else if(nameData=="Speed")
		{
			if(data[0]==32)
			{
				string@[]check=splitEx(data," ");
				data=join(check,"");
			}
			
			Speed=data.ToFloat();
		}
		else if(nameData=="Flags")
		{
			Flags=data;
		}
		else if(nameData=="Mimic")
		{
			AddReference(data,Mimic);
		}
	}
	
	int opCmp(ProtoBiom@other)
	{
		if(other.Name==this.Name)
		return 0;
		
		for(uint i=0,iEnd=Mimic.length();i<iEnd;i++)
		{
			ProtoBiom@mimic=cast<ProtoBiom@>(@Mimic[i].GetThis());
			if(@mimic!is null&&mimic.Name==other.Name)
			return 1;
		}
		
		for(uint i=0,iEnd=other.Mimic.length();i<iEnd;i++)
		{
			ProtoBiom@mimic=cast<ProtoBiom@>(@other.Mimic[i].GetThis());
			if(@mimic!is null&&mimic.Name==Name)
			return 1;
		}
		
		return-1;
	}
}

class ContentFlags
{
	ContentFlags(){this=false;}
	
	private void Set(string&in data)
	{
		this=false;
		string@[]args=splitEx(data," ");
		for(uint i=0,iEnd=args.length();i<iEnd;i++)
		{
			if(args[i]=="Static")Static=true;
			else if(args[i]=="Encounter")Encounter=true;
			else if(args[i]=="Hidden")Hidden=true;
			else if(args[i]=="Ignored")Ignored=true;
			else if(args[i]=="SpawnItems")SpawnItems=true;
		}
	}
	
	ContentFlags&opAssign(bool&in value)
	{
		Hidden=
		Ignored=
		Encounter=
		SpawnItems=
		Static=value;
		return this;
	}
	
	ContentFlags&opAssign(ContentFlags&in value)
	{
		this.Hidden=value.Hidden;
		this.Ignored=value.Ignored;
		this.Encounter=value.Encounter;
		this.SpawnItems=value.SpawnItems;
		this.Static=value.Static;
		return this;
	}
	
	ContentFlags&opAssign(string&in value)
	{
		Set(value);
		return this;
	}
	
	string@get_Debug()
	{
		string result="";
		if(Hidden)result+="Hidden ";
		if(Ignored)result+="Ignored ";
		if(Encounter)result+="Encounter ";
		if(SpawnItems)result+="SpawnItems ";
		if(Static)result+="Static ";
		return result;
	}
	
	bool Static;
	bool Encounter;
	bool Ignored;
	bool Hidden;
	bool SpawnItems;
}

class BiomFlags
{
	BiomFlags(){this=false;}
	
	private void Set(string&in data)
	{
		string@[]args=splitEx(data," ");
		for(uint i=0,iEnd=args.length();i<iEnd;i++)
		{
			if(args[i]=="Orientation")Orientation=true;
			if(args[i]=="Direction")Direction=true;
		}
	}
	
	BiomFlags&opAssign(bool&in value)
	{
		Orientation=
		Direction=value;
		return this;
	}
	
	BiomFlags&opAssign(BiomFlags&in value)
	{
		this.Orientation=value.Orientation;
		this.Direction=value.Direction;
		return this;
	}
	
	BiomFlags&opAssign(string&in value)
	{
		Set(value);
		return this;
	}
	
	bool Direction;
	bool Orientation;
}

ContentInfo@CreateStaticContent(const string&in name)
{
	ContentInfo info(name);
	info.Flags.Static=true;
	return@info;
}

ContentInfo@CreateEncounterContent(const string&in name)
{
	ContentInfo info(name);
	info.Flags.Encounter=
	info.Flags.SpawnItems=
	true;
	info.Visible=100;
	return@info;
}

class ContentInfo:FileObject,AnyDataObject
{
	uint16 LocationPid;
	int8 Visible;
	string Name;
	string ClientSymbol;
	Hexagonal Size;
	
	uint ColorSymbol;
	uint ColorCell;
	ContentFlags Flags;
	
	ContentInfo(const string&name)
	{
		Size.Set(1,1);
		Name=name;
		Visible=0;
		ClientSymbol="S";
		ColorSymbol=(uint((0xFF<<24)|(((16)&0xFF)<<16)|(((230)&0xFF)<<8)|((130)&0xFF)));
		ColorCell=0x442222DD;
		LocationPid=0;
		Flags=false;
		GlobalDataList.resize(0);
	}
	
	void Prepare()override{}
	
	uint[]@get_SaveData()override
	{
		uint[]data;
		uint position=0;
		for(uint i=0,iEnd=GlobalDataList.length();i<iEnd;i++)
		GlobalDataList[i].SaveData(data,position);
		return data;
	}
	
	void InitData(uint[]&data)override
	{
		uint position=0;
		for(uint i=0,iEnd=GlobalDataList.length();i<iEnd;i++)
		GlobalDataList[i].LoadData(data,position);
	}
	
	void set_GlobalData(string@name,string@value)override
	
	{
		const uint hash=GetStrHash(name);
		for(uint i=0,iEnd=GlobalDataList.length();i<iEnd;i++)
		if(GlobalDataList[i].Hash==hash)
		{
			GlobalDataList[i].Value=value;
			return;
		}
	}
	
	string@get_GlobalData(string@name)override
	
	{
		const uint hash=GetStrHash(name);
		for(uint i=0,iEnd=GlobalDataList.length();i<iEnd;i++)
		if(GlobalDataList[i].Hash==hash)
		return GlobalDataList[i].Value;
		return null;
	}
	
	private GlobalData@[]GlobalDataList;
	
	string@get_DictKey()override{return""+LocationPid;}
	string@get_ObjectName()const override{return"ContentInfo";}
	FileObject@get_Pattern(string&name)const override{return ContentInfo(name);}
	
	FileObject@get_Copy(string&name)override
	{
		ContentInfo@copy=ContentInfo(name);
		
		copy.LocationPid=this.LocationPid;
		copy.Flags=this.Flags;
		copy.Visible=this.Visible;
		copy.Size=this.Size;
		
		return@copy;
	}
	
	uint FormatColor(const string&data)
	{
		uint8 colorCount=0;
		uint8[]colors(0);
		int buffer=0;
		::string@[]colorsStr=::splitEx(data," ");
		for(uint i=0,iEnd=colorsStr.length();i<iEnd;i++)
		{
			if(::StrToInt(colorsStr[i],buffer))
			if(colorCount++<4)
			colors.insertLast(uint8(buffer));
		}
		
		if(colorCount>=3)
		{
			if(colorCount==4)
			return(((((uint((0xFF<<24)|(((colors[0])&0xFF)<<16)|(((colors[1])&0xFF)<<8)|((colors[2])&0xFF))))|0xFF000000)^0xFF000000)|((colors[3])&0xFF)<<24);
			else return(uint((0xFF<<24)|(((colors[0])&0xFF)<<16)|(((colors[1])&0xFF)<<8)|((colors[2])&0xFF)));
		}
		return 0;
	}
	
	void FormatStringData(string&nameData,string&data)override
	{
		string@[]args=splitEx(nameData,":");
		if(args.length()>=1)
		{
			if(args.length()==1)
			{
				if(nameData=="LocationPid")
				{
					int mem=0;
					if(data[0]==32)
					{
						string@[]check=splitEx(data," ");
						data=join(check,"");
					}
					StrToInt(data,mem);
					LocationPid=mem;
				}
				else if(nameData=="Size")
				{
					string@[]xy=splitEx(data," ");
					int mem=0;
					if(xy[0][0]==32)
					{
						string@[]check=splitEx(xy[0]," ");
						xy[0]=join(check,"");
					}
					StrToInt(xy[0],mem);
					Size.X=mem;
					if(xy[1][0]==32)
					{
						string@[]check=splitEx(xy[1]," ");
						xy[1]=join(check,"");
					}
					StrToInt(xy[1],mem);
					Size.Y=mem;
				}
				else if(nameData=="GlobalData")
				{
					string@[]globals=splitEx(data," ");
					for(uint i=0,iEnd=globals.length();i<iEnd;i++)
					GlobalDataList.insertLast(GlobalData(globals[i]));
				}
				else if(nameData=="Flags")
				{
					Flags=data;
				}
				else if(nameData=="Name")
				{
					if(data[0]==32)
					{
						string@[]check=splitEx(data," ");
						data=join(check,"");
					}
					
					Name=data;
				}
				else if(nameData=="Visible")
				{
					int mem=0;
					if(data[0]==32)
					{
						string@[]check=splitEx(data," ");
						data=join(check,"");
					}
					
					StrToInt(data,mem);
					Visible=mem;
				}
			}
			else if(args.length()==2)
			{
				if(args[0]=="Create")
				{
					WorldLocation location;
					location.Name=args[1];
					
					string@[]xy=splitEx(data," ");
					int mem=0;
					if(xy[0][0]==32)
					{
						string@[]check=splitEx(xy[0]," ");
						xy[0]=join(check,"");
					}
					StrToInt(xy[0],mem);
					location.Position.X=mem;
					if(xy[1][0]==32)
					{
						string@[]check=splitEx(xy[1]," ");
						xy[1]=join(check,"");
					}
					StrToInt(xy[1],mem);
					location.Position.Y=mem;
					
					@location.Content=this;
					
					if(Flags.Static)
					{
						if(Flags.Hidden)
						Global::World.HiddenLocations.insertLast(@location);
						Global::World.StaticLocations.insertLast(@location);
					}
				}
				else if(args[0]=="Cell")
				{
					if(args[1]=="Color")
					{
						ColorCell=FormatColor(data);
					}
				}
				else if(args[0]=="Symbol")
				{
					if(args[1]=="Color")
					ColorSymbol=FormatColor(data);
					else if(args[1]=="Client")
					{
						if(data.length()!=1)
						{
							string@[]check=splitEx(data," ");
							data=join(check,"");
						}
						
						Log(Name+" ClientSymbol = "+data);
						ClientSymbol=data;
					}
				}
			}
		}
	}
}

class CellContent
{
	void DeadQueen(Critter&critter)
	{
		if(@prv_MainKind!is null)
		prv_MainKind.DeadQueen(critter,this);
	}
	
	void Drop(Hexagonal&position,ContentInfo@info)
	{
		Drop(position,@info,@prv_MainKind);
	}
	
	void Drop(Hexagonal&position,ContentInfo@info,KindInstance@kind)
	{
		@prv_MainKind=@kind;
		@Info=@info;
		RealPosition=position;
		
		MapId=0;
	} 
	
	ContentInfo@Info;
	
	private Hexagonal RealPosition;
	private uint RealMapId;
	
	private KindInstance@prv_MainKind; 
	
	~CellContent(){@CurrentKind=null;} 
	
	CellContent(Hexagonal&position){Drop(position,@Global::World.DefaultContent);}
	CellContent(Hexagonal&position,ContentInfo@info){Drop(position,@info);}
	CellContent(Hexagonal&position,ContentInfo@info,uint mapId)
	{
		Drop(position,@info);
		MapId=mapId;
		
	}
	CellContent(Hexagonal&position,ContentInfo@info,uint mapId,KindInstance@kind)
	{
		Drop(position,@info,@kind);
		MapId=mapId;
	} 
	
	Map@GetMap(){uint mapid=MapId;if(mapid==0)return null;return::GetMap(mapid);}
	uint get_MapId(){return RealMapId;}
	Location@get_Location()
	{
		Map@map=this.GetMap();
		if(@map!is null)
		return map.GetLocation();
		return null;
	}
	
	Cell@get_Cell(){return@Global::World.GetCell(RealPosition);}
	Hexagonal@get_Position(){return@Hexagonal(RealPosition);}
	void set_Position(Hexagonal&value)
	{
		for(uint x=0;x<Info.Size.X;x++)
		for(uint y=0;y<Info.Size.Y;y++)
		{
			Cell@cell=Global::World.GetCell(x,y);
			if(@cell!is null)
			cell.DeleteContent(this);
		}
		
		RealPosition=value;
		this.Cell=this;
	}
	
	Kind@get_CurrentKind()
	{
		if(@prv_MainKind!is null)
		return@prv_MainKind.Proto;
		return null;
	} 
	
	uint set_MapId(uint mapid)
	{
		if(mapid!=RealMapId)
		{
			RealMapId=mapid;
			Map@map=this.GetMap();
			if(@map is null)
			{
				RealMapId=0;
				return 0;
			}
			
			if(@prv_MainKind!is null)
			prv_MainKind.Spawn(map);
		}
		return RealMapId;
	}
	
	void set_CurrentKind(Kind@value)
	{
		if(@prv_MainKind is null&&@value is null)
		return;
		
		if(@prv_MainKind!is null)
		{
			if(@prv_MainKind.Proto is@value)
			return;
			prv_MainKind.Kill();
		}
		if(@value is null)
		@prv_MainKind=null;
		else
		{
			@prv_MainKind=KindInstance(value,@this.Cell);
			if(MapId!=0)
			{
				Map@map=::GetMap(MapId);
				if(@map!is null)
				{
					prv_MainKind.Spawn(map);
				}
			}
		}
	}
	
	CellContent&opAssign(Map&map)
	{
		MapId=map.Id;
		return this;
	} 
	
}

class Cell
{
	Hexagonal Position;
	
	MapPacket@MapPack;
	private ProtoBiom@CurrentBiom;
	
	CellContent@Content;
	CellContent@HiddenContent;
	
	Zone@[]ZoneList;
	
	int FigureIndex;
	
	void Log(string@str)
	{
		::ClearLog("Cell<"+Position.X+" "+Position.Y+"> : "+str);
	}
	
	ProtoBiom@Biom
	{
		set
		{
			if(@CurrentBiom!is null)
			CurrentBiom.EraseCell(@this);
			
			@CurrentBiom=value;
			if(@value!is null)
			value.AddBiom(@this);
		}
		
		get
		{
			return@CurrentBiom;
		}
	}
	
	Cell()
	{
		@MapPack=null;
		@CurrentBiom=null;
		@Content=null;
		@HiddenContent=null;
		FigureIndex=-1;
	}
	
	bool SetLocation(uint16 protoId)
	{
		Content.Drop(Position,@Global::World.DefaultContent);
		
		Location@location=@GetLocation(CreateLocation(Position,protoId));
		if(@location is null)
		return false;
		
		Content=location.GetMapByIndex(0);
		
		return true;
	}
	
	int CellCreate(uint16 protoId,bool force)
	{
		if(!force)
		return-1;
		
		if(!SetLocation(protoId))
		return-2;
		
		return 0;
	}
	
	int CellCreate(uint16 protoId,int wildness,int livetime,bool force)
	{
		if(!force)
		return-1;
		
		if(!SetLocation(protoId))
		return-2;
		
		return 0;
	}
	
	void CellDelete()
	{
		Map@map=@Content.GetMap();
		if(@map!is null)
		DeleteLocation(map.GetLocation().Id);
		Content.Drop(Position,@ContentInfo());
	}
	
	void SetSize(uint x,uint y)
	{
		if(@Content!is null&&Position==Content.Position)
		{
			for(uint i=0;i<y;++i)
			for(uint j=0;j<x;++j)
			{
				Cell@cell=@Global::World.GetCell(Position.X-j,Position.Y+i);
				if(@cell is null||@cell is@this)
				continue;
				
				cell=Content;
			}
		}
	}
	
	void DeleteContent(CellContent&content)
	{
		if(content.Info.Flags.Hidden&&@content is@HiddenContent)
		@HiddenContent=null;
		else if(@content is@Content)@Content=null;
	}
	
	Cell&opAssign(CellContent&content)
	{
		if(content.Info.Flags.Hidden)
		@HiddenContent=content;
		else@Content=content;
		
		SetSize(content.Info.Size.X,content.Info.Size.Y);
		return this;
	}
	
	CellContent@GetMapContent(Map&map){return GetMapContent(map.Id);}
	CellContent@GetMapContent(uint mapId)
	{
		if(Content.MapId==mapId)
		return Content;
		else
		{
			Map@map=GetMap(Content.MapId);
			if(@map!is null)
			{
				Location@location=map.GetLocation();
				for(uint i=0,iEnd=location.GetMapCount();i<iEnd;i++)
				if(location.GetMapByIndex(i).Id==mapId)
				return Content;
			}
		}
		if(@HiddenContent!is null)
		{
			if(HiddenContent.MapId==mapId)
			return HiddenContent;
			Map@map=GetMap(HiddenContent.MapId);
			if(@map!is null)
			{
				Location@location=map.GetLocation();
				for(uint i=0,iEnd=location.GetMapCount();i<iEnd;i++)
				if(location.GetMapByIndex(i).Id==mapId)
				return HiddenContent;
			}
		}
		return null;
	}
	
	int opCmp(Zone@zone)
	{
		for(uint i=0,iEnd=ZoneList.length();i<iEnd;i++)
		if(zone.Name==ZoneList[i].Name)
		return 0;
		return-1;
	}
}

class Zone:FileObject
{
	Zone(string@name)
	{
		Name=name;
		X.Set(0);
		Y.Set(0);
	}
	
	CountValue X;
	CountValue Y;
	string Name;
	
	void Prepare()override
	{
		Global::World.ZoneList.insertLast(this);
	}
	
	string@get_DictKey()override{return Name;}
	string@get_ObjectName()const override{return"Zone";}
	void FormatStringData(string&nameData,string&data)override
	{
		string@[]args=splitEx(nameData,":");
		if(args.length()>=1)
		{
			if(args.length()==1)
			{
				if(nameData=="GlobalData")
				{
					string@[]globals=splitEx(data," ");
					for(uint i=0,iEnd=globals.length();i<iEnd;i++)
					GlobalDataList.insertLast(GlobalData(globals[i]));
				}
				else if(nameData=="X")
				{
					X.Set(data);
				}
				else if(nameData=="Y")
				{
					Y.Set(data);
				}
			}
		}
	}
	
	FileObject@get_Pattern(string&name)const override{return Zone(name);}
	FileObject@get_Copy(string&name)override
	{
		Zone copy(name);
		return copy;
	}
	
	void set_GlobalData(string@name,string@value)override
	{
		const uint hash=GetStrHash(name);
		for(uint i=0,iEnd=GlobalDataList.length();i<iEnd;i++)
		if(GlobalDataList[i].Hash==hash)
		{
			GlobalDataList[i].Value=value;
			return;
		}
	}
	
	string@get_GlobalData(string@name)override
	{
		const uint hash=GetStrHash(name);
		for(uint i=0,iEnd=GlobalDataList.length();i<iEnd;i++)
		if(GlobalDataList[i].Hash==hash)
		return GlobalDataList[i].Value;
		return null;
	}
	
	private GlobalData@[]GlobalDataList;
	
}

class WorldLocation
{
	ContentInfo@Content;
	Hexagonal Position;
	
	private string _Name;
	string Name
	{
		get{return _Name;}
		set{_Name=value;HashName=GetStrHash(value);}
	}
	
	void Create()
	{
		if(Content.LocationPid!=0)
		{
			if((Id=CreateLocation(Position,Content.LocationPid))==0)
			Log("Error create static location");
			else
			{
				Location@location=this.Location;
				if(@location!is null)location.HashStaticName=HashName;
				else Log("Error checked static location");
			}
		}
		else Log("Error content locpid static location is 0");
	}
	
	WorldLocation@opAssign(Location@value)
	{
		Id=value.Id;
		return this;
	}
	
	Location@get_Location(){return GetLocation(Id);}
	Map@get_Map(){return this.Location.GetMapByIndex(0);}
	
	uint HashName;
	uint Id;
}

class OrientationFigure
{
	Cell@[]@cells;
	Zone@zone;
	string Name;
	
	OrientationFigure(string&name)
	{
		@cells=array<Cell@>(0);
		@zone=Zone("Zone"+name);
		Name=name;
	}
	
	void opAddAssign(Cell&cell)
	{
		cells.insertLast(@cell);
		if(cell.Position.X<zone.X.Min)
		zone.X.Min=cell.Position.X;
		if(cell.Position.X>zone.X.Max)
		zone.X.Max=cell.Position.X;
		if(cell.Position.Y<zone.Y.Min)
		zone.Y.Min=cell.Position.Y;
		if(cell.Position.Y>zone.Y.Max)
		zone.Y.Max=cell.Position.Y;
	}
}

class World:ManagerObject,iManagerModule,iManager_map_critter_in,iManager_world_save,iManager_critter_dead,iManager_critter_init,iManager_critter_respawn
{
	Cell[]Cells;
	
	bool IsStart;
	
	private uint16 Width;
	private uint16 Height;
	private AnyDataObject@[]AnyDataList;
	Zone@[]ZoneList;
	WorldLocation@[]StaticLocations;
	WorldLocation@[]HiddenLocations;
	OrientationFigure@[]Figures;
	
	dictionary Prototypes;
	
	WorldLocation@get_HiddenLocation(uint hash)
	{
		for(uint i=0,iEnd=HiddenLocations.length();i<iEnd;i++)
		if(HiddenLocations[i].HashName==hash)
		return HiddenLocations[i];
		return null;
	}
	
	WorldLocation@get_StaticLocation(uint hash)
	{
		for(uint i=0,iEnd=StaticLocations.length();i<iEnd;i++)
		if(StaticLocations[i].HashName==hash)
		return StaticLocations[i];
		return null;
	}
	
	WorldLocation@get_WorldLocation(uint hash)
	{
		WorldLocation@location=StaticLocation[hash];
		
		if(@location is null)
		@location=HiddenLocation[hash];
		
		return location;
	}
	
	ContentInfo@DefaultContent;
	MapHash@[]HashMaps;
	
	ProtoSettings@Settings;
	
	World()
	{
		IsStart=false;
		@DefaultContent=@CreateEncounterContent("Encounter");
		@Settings=@ProtoSettings("Default");
		SetEventCallback("Init",Init);
		SetEventCallback("Start",Start);
		SetEventCallback("WorldGeneration",WorldGeneration);
		
		Width=35;
		Height=60;
		Cells.resize(Width*Height);
		for(uint y=0;y<Height;y++)
		{
			const uint cy=y*Width;
			for(uint x=0;x<Width;x++)
			{
				Cells[x+cy].Position.Set(x,y);
			}
		}
	}
	
	MapHash@get_Hash(const uint16&mapPid)
	{
		if(HashMaps.length()<=mapPid)
		GetMapHash(mapPid);
		if(@HashMaps[mapPid]is null)
		@HashMaps[mapPid]=MapHash(mapPid);
		return@HashMaps[mapPid];
	}
	
	MapHash@GetHash(Map&map)
	{
		MapHash@ret=@Hash[map.GetProtoId()];
		if(@ret is null)
		{
			Log("Error");
			return null;
		}
		ret=map;
		return@ret;
	}
	
	ProtoBiom@GetBiom(const Hexagonal&in hex)
	{
		Cell@cell=GetCell(hex);
		if(@cell!is null)
		return@cell.Biom;
		return null;
	}
	
	bool CoordinateToDir(const uint8 direction,Hexagonal&inout position)
	{
		switch(direction)
		{
			case 0:
			if(position.Y==0)return false;
			position.Y--;
			case 1:
			if(position.X>=Width-1)return false;
			position.X++;
			break;
			case 2:
			if(position.X>=Width-1)return false;
			position.X++;
			case 3:
			if(position.Y>=Height-1)return false;
			position.Y++;
			break;
			case 4:
			if(position.Y>=Height-1)return false;
			position.Y++;
			case 5:
			if(position.X==0)return false;
			position.X--;
			break;
			case 6:
			if(position.X==0)return false;
			position.X--;
			case 7:
			if(position.Y==0)return false;
			position.Y--;
			break;
			default:
			return false;
		}
		return true;
	}
	
	Cell@CellToDir(Cell&cell,uint8 direction)
	{
		return@CellToDir(cell.Position,direction);
	}
	
	Cell@CellToDir(Hexagonal&in position,uint8 direction)
	{
		if(!CoordinateToDir(direction,position))
		return null;
		return@GetCell(position);
	}
	
	bool manager_init()
	{
		ParseProtoTypes("cfg",ProtoSettings("Pattern"),"./NextDay/");
		
		ParseProtoTypes("biom",ProtoBiom("Pattern"),"./NextDay/");
		ParseProtoTypes("zone",Zone("Pattern"),"./NextDay/");
		ParseProtoTypes("content",DefaultContent,"./NextDay/");
		ParseProtoTypes("hierarchy",Hierarchy("Pattern"),"./NextDay/");
		ParseProtoTypes("kind",Kind("Pattern"),"./NextDay/");
		return true;
	}
	
	bool manager_start()
	{
		IsStart=true;
		
		ClearLog("Сборка мира: "+ParseCellSet());
		Start();
		
		for(uint i=0,iEnd=AnyDataList.length();i<iEnd;i++)
		{
			AnyDataObject@anyD=AnyDataList[i];
			if(@anyD!is null)
			{
				uint[]data;
				if(IsAnyData(anyD.ObjectName+":"+anyD.DictKey)&&GetAnyData(anyD.ObjectName+":"+anyD.DictKey,data))
				anyD.InitData(data);
				else anyD.InitData(anyD.SaveData);
			}
		}
		
		return true;
	}
	
	string ParseCellSet()
	{
		string@txt=@LoadFile("./NextDay/world.mapbiom");
		if(@txt is null||txt.length()==0)
		return"Ошибка загрузки файла <"+"./NextDay/world.mapbiom"+">";
		
		string@[]fileH=splitEx(txt,"\n");
		uint maxH=fileH.length();
		if(maxH!=Height)
		return"Высота мира не корректена. ParseFile "+maxH+" world "+Height;
		
		for(uint y=0;y<maxH;y++)
		{
			string@[]fileW=splitEx(fileH[y],"\t");
			uint maxW=fileW.length();
			if(maxW!=Width)
			return("Ширина мира не корректена. Строка "+y+" ParseFile "+maxW+" world "+Width);
			
			for(uint x=0;x<maxW;x++)
			if(!Prototypes.exists("ProtoBiom:"+fileW[x]))
			Log("Не установленный символ биома: <"+fileW[x]+">");
			else
			{
				Prototypes.get("ProtoBiom:"+fileW[x],@Cells[x+(y*maxW)].Biom);
				@Cells[x+(y*maxW)].MapPack=@Cells[x+(y*maxW)].Biom.Default;
			}
		}                              
		
		uint tick=GetTick();
		Rebuild();
		
		return"Успешно. "+(GetTick()-tick)+"ms";
	}
	
	private void Rebuild(uint x,uint y)
	{
		const string[]dirChars={"E","S","W","N"};
		uint cellIndex=x+(y*Width);
		
		Hexagonal hex(x,y);
		ProtoBiom@currentBiom=@Cells[cellIndex].Biom;
		uint[]@dirs=GetBiomDirs(hex,currentBiom);
		if(dirs.length()!=4)
		{
			string@dirChar=@FormatDirStr(dirs,dirChars);
			if(@dirChar!is null)
			{
				if(!currentBiom.MapPackets.exists(dirChar))
				Log("Не установленный пак карт: "+currentBiom.Name+"<"+dirChar+">");
				else
				{
					bool isConvert=false;
					for(uint index=0,iEnd=currentBiom.ConversionsData.length();index<iEnd&&!isConvert;index++)
					{
						BiomConversion@conv=currentBiom.ConversionsData[index];
						ProtoBiom@ifBiom=@this.GetProtoBiom(conv.IfBiom);
						ProtoBiom@convBiom=@this.GetProtoBiom(conv.ToConvert);
						if(@convBiom is null)
						Log("Не найден биом <"+conv.ToConvert+">, конвертация невозможна.");
						else if(@ifBiom is null)
						Log("Не найден биом <"+conv.IfBiom+">, конвертация невозможна.");
						else
						{
							uint[]dirsInvert=InvertDirs(dirs);
							if(IsBiomDirs(hex,dirsInvert,ifBiom))
							{
								string@dirCharInvert=@FormatDirStr(dirsInvert,dirChars);
								if(!convBiom.MapPackets.exists(dirCharInvert))
								Log("Не установленный пак карт: "+convBiom.Name+"<"+dirCharInvert+">");
								else
								{
									@Cells[cellIndex].Biom=convBiom;
									isConvert=true;
									convBiom.MapPackets.get(dirCharInvert,@Cells[cellIndex].MapPack);
								}
							}
						}
					}
					if(!isConvert)
					currentBiom.MapPackets.get(dirChar,@Cells[cellIndex].MapPack);
				}
			}
		}
	}
	
	private void ParseFigure(ProtoBiom&biom,Cell&cell,OrientationFigure&figure,int index)
	{
		cell.FigureIndex=index;
		figure+=cell;
		for(uint direction=0;direction<4;direction++)
		{
			Cell@icell=CellToDir(cell,direction*2+1);
			if(@icell!is null&&icell.FigureIndex==-1&&icell.Biom==biom)
			{
				ParseFigure(biom,icell,figure,index);
			}
			
		}
	}
	
	private void Rebuild()
	{
		const string[]dirChars={"E","S","W","N"};
		Hexagonal hex(0,0);
		
		for(;hex.Y<Height;hex.Y++)
		{
			for(hex.X=0;hex.X<Width;hex.X++)
			{
				Cell@cell=Cells[hex.UID[Width]];
				ProtoBiom@currentBiom=cell.Biom;
				if(cell.FigureIndex==-1&&currentBiom.Flags.Orientation)
				{
					OrientationFigure figure("Figure"+Figures.length());
					ParseFigure(currentBiom,cell,figure,Figures.length());
					Figures.insertLast(figure);
				}
				uint[]@dirs=GetBiomDirs(hex,currentBiom);
				if(dirs.length()!=4)
				{
					string@dirChar=FormatDirStr(dirs,dirChars);
					if(@dirChar!is null)
					{
						if(!currentBiom.MapPackets.exists(dirChar))
						Log("Не установленный пак карт: "+currentBiom.Name+"<"+dirChar+">");
						else
						{
							bool isConvert=false;
							for(uint index=0,iEnd=currentBiom.ConversionsData.length();index<iEnd&&!isConvert;index++)
							{
								BiomConversion@conv=currentBiom.ConversionsData[index];
								ProtoBiom@ifBiom=GetProtoBiom(conv.IfBiom);
								ProtoBiom@convBiom=GetProtoBiom(conv.ToConvert);
								if(@convBiom is null)
								Log("Не найден биом <"+conv.ToConvert+">, конвертация невозможна.");
								else if(@ifBiom is null)
								Log("Не найден биом <"+conv.IfBiom+">, конвертация невозможна.");
								else
								{
									uint[]@dirsInvert=InvertDirs(dirs);
									if(IsBiomDirs(hex,dirsInvert,ifBiom))
									{
										string@dirCharInvert=FormatDirStr(dirsInvert,dirChars);
										if(!convBiom.MapPackets.exists(dirCharInvert))
										Log("Не установленный пак карт: "+convBiom.Name+"<"+dirCharInvert+">");
										else
										{
											@cell.Biom=convBiom;
											isConvert=true;
											convBiom.MapPackets.get(dirCharInvert,@cell.MapPack);
											Rebuild(hex.X-1,hex.Y);
											Rebuild(hex.X,hex.Y-1);
										}
									}
								}
							}
							if(!isConvert)
							currentBiom.MapPackets.get(dirChar,@cell.MapPack);
						}
					}
				}
				PrepareCell(cell,hex);
			}
		}
		
		ClearLog("Фигур найдено: "+Figures.length());
	}
	
	private void PrepareCell(Cell&cell,Hexagonal&position)
	{
		for(uint i=0,iEnd=ZoneList.length();i<iEnd;i++)
		{
			Zone@zone=ZoneList[i];
			if(zone.X.Min<=position.X&&zone.X.Max>=position.X&&
			zone.Y.Min<=position.Y&&zone.Y.Max>=position.Y)
			cell.ZoneList.insertLast(zone);
		}
	}
	
	string@FormatDirStr(const uint[]&in dirs,const string[]&chars)
	{
		string ret="";
		for(uint i=0,iEnd=dirs.length();i<iEnd;i++)
		ret+=chars[dirs[i]];
		if(ret=="")
		return null;
		return@ret;
	}
	
	uint[]@InvertDirs(const uint[]&in dirs)
	{
		uint[]ret(0);
		for(uint d=0,dCount=dirs.length();d<dCount;d++)
		ret.insertLast((dirs[d]+1)%4);
		ret.sortAsc();
		return ret;
	}
	
	bool IsBiomDir(Hexagonal&in position,const uint direction,ProtoBiom&in currentBiom)
	{
		return(CoordinateToDir(direction,position)&&currentBiom>=GetBiom(position));
	}
	
	bool IsBiomDirs(Hexagonal&in position,const uint[]&in dirs,ProtoBiom&in currentBiom)
	{
		for(uint d=0,dCount=dirs.length();d<dCount;d++)
		if(!IsBiomDir(position,dirs[d]*2+1,currentBiom))
		return false;
		return true;
	}
	
	bool global_critter_respawn(Critter&critter)override
	{
		if(critter.IsNpc()&&critter.KindHierarchy!=Kind::Hierarchy::None)
		DeleteNpc(critter);
		return true;
	}
	
	bool global_critter_init(Critter&critter,bool firstTime)
	{
		if(critter.IsNpc()&&critter.KindHierarchy!=Kind::Hierarchy::None&&!firstTime)
		{
			critter.KindHierarchy=Kind::Hierarchy::None;
			critter.KindIndex=0;
			DeleteNpc(critter);
			return false;
		}
		return true;
	}
	
	bool global_critter_dead(Critter&critter,Critter@killer)
	{
		if(critter.IsNpc()&&critter.KindHierarchy!=Kind::Hierarchy::None)
		{
			Cell@cell=@GetCell(critter);
			if(@cell!is null)
			cell.Content.DeadQueen(critter);
		}
		return true;
	}
	
	uint[]@GetBiomDirs(Hexagonal&in position,const ProtoBiom&in currentBiom)
	{
		if(currentBiom.Flags.Direction)
		{
			uint[]ret={};
			for(uint direction=0;direction<4;direction++)
			if(IsBiomDir(position,direction*2+1,currentBiom))
			ret.insertLast(direction);
			
			if(ret.length()==1)
			{
				for(uint direction=0;direction<4;direction++)
				if(ret.find(direction)==-1)
				{
					Hexagonal pos=position;
					if(!CoordinateToDir(direction*2+1,pos))
					{
						ret.insertLast(direction);
						break;
					}
				}
				
				ret.sortDesc();
			}
			return ret;
		}
		return uint[](0);
	}
	
	void ParseProtoTypes(const string&ex,const FileObject&pattern,const string@path)override
	{
		uint tick=GetTick();
		string fileNames;
		if(GetFolders(path+"*",fileNames))
		{
			string@[]paths=splitEx(fileNames,"\n");
			for(uint i=0,iEnd=paths.length();i<iEnd;i++)
			if(paths[i].length()>0&&paths[i]!="."&&paths[i]!="..")
			this.ParseProtoTypes(ex,pattern,path+paths[i]+"\\");
		}
		fileNames="";
		if(GetFolderFiles(path+"*."+ex,fileNames))
		{
			string@[]namesFile=splitEx(fileNames,"\n");
			for(uint i=0,iEnd=namesFile.length();i<iEnd;i++)
			{
				string@[]names=splitEx(namesFile[i],".");
				ParseProtoTypeFile(names[0],ex,pattern,path);
			}
		}
		ClearLog("Parse <"+pattern.ObjectName+"><"+ex+"> "+(GetTick()-tick)+"ms");
	}
	
	FileObject@ParseProtoTypeFile(string&name,const string&ex,const FileObject&pattern,const string@path)override
	{
		string@txt=@LoadFile(path+name+"."+ex);
		if(@txt!is null)
		{
			::string@[]data=::splitEx(name," ");
			return AddPrototype(@StringToFileObject(join(data,""),txt,pattern));
		}
		return null;
	}
	
	FileObject@AddPrototype(FileObject@proto)override
	{
		Prototypes.set(proto.ObjectName+":"+proto.DictKey,@proto);
		
		AnyDataObject@anyD=cast<AnyDataObject@>(@proto);
		if(@anyD!is null)
		AnyDataList.insertLast(@anyD);
		proto.Prepare();
		Handle@handle=Handle::Create(proto);
		RunEvent("Create"+proto.ObjectName,handle);
		RunEvent("CreatePrototype",handle);
		Log("Add proto : <"+proto.ObjectName+"> : <"+proto.DictKey+">");
		return proto;
	}
	
	FileObject@StringToFileObject(string&name,string&txt,const FileObject&pattern)override
	{
		string@[]lines=splitEx(txt,"\n");
		const uint countLine=lines.length(); 
		
		if(countLine==0)
		return null;
		
		FileObject@proto=@pattern.Pattern[name];
		::string@currentLine=null;
		for(uint i=0;i<countLine;i++)
		{
			@currentLine=lines[i];
			if(@currentLine is null||currentLine.length()==0)
			continue;
			
			if(currentLine[0]==35)
			{
				continue;
			}
			
			::string@[]data=::splitEx(currentLine,"#");
			if(data.length()>1)
			@currentLine=data[0];
			data=::splitEx(currentLine,"=");
			if(data.length()==2)
			{
				string@[]check=splitEx(data[1],"\t");
				data[1]=join(check," ");
				
				check=splitEx(data[1]," ");
				data[1]=join(check," ");
				
				proto.FormatStringData(data[0],data[1]);
			}
			else if(data.length()==1)
			{
				data=::splitEx(data[0]," ");
				if(data.length()>=1)
				{
					if(data[0]=="new")
					{
						data.removeAt(0);
						AddPrototype(@proto);
						@proto=@pattern.Pattern[join(data,"")];
					}
					else if(data[0]=="copy")
					{
						data.removeAt(0);
						AddPrototype(@proto);
						@proto=@proto.Copy[join(data,"")];
					}
				}
			}
		}
		return proto;
	}
	
	uint GetCells(Cell@[]&cells,const Hexagonal&in position,uint8 radius)
	{
		uint length=cells.length(),
		lengthMax=length;
		
		if(radius==0)
		return length;
		
		for(uint8 i=1;i<=radius;i++)
		lengthMax+=i*8;
		
		cells.resize(lengthMax);
		int x0=position.X,y0=position.Y;
		
		int h=1,g=0,u=0,r=1;
		
		for(uint i=length;i<lengthMax;i++)
		{
			u=(g/h);
			
			x0+=(1-u)*r;
			y0+=u*r;
			
			@cells[i]=@GetCell(x0,y0);
			g++;
			if(g>=h*2)
			{
				g=0;
				h+=1;
				r*=-1;
			}
		}
		
		return cells.length();
	}
	
	Cell@GetCell(Location&location){return@GetCell(location.WorldX/10+location.WorldY/10*Width);}
	Cell@GetCell(Map&map){return@GetCell(map.GetLocation());}
	Cell@GetCell(uint16 x,uint16 y){return@GetCell(x+y*Width);}
	Cell@GetCell(const Hexagonal&in hex){return@GetCell(hex.UID[Width]);}
	Cell@GetCell(uint i)
	{
		if(i>=Cells.length())
		return null;
		return@Cells[i];
	}
	
	Cell@GetCell(Critter&critter)
	{
		Map@map=critter.GetMap();
		if(@map!is null)
		{
			Cell@cell=GetCell(map);
			CellContent@content=cell.GetMapContent(map);
			if(@content!is null)
			{
				if(content.Info.Size.X>1||content.Info.Size.Y>1)
				{
					Hexagonal globalPosition=content.Position,
					mapHex,
					playerHex(critter);
					mapHex.Entire(map,(255));
					
					playerHex.X-=mapHex.X;
					if(playerHex.Y>=mapHex.Y)
					playerHex.Y-=mapHex.Y;
					else playerHex.Y=0;
					
					globalPosition.X-=playerHex.X/(150);
					globalPosition.Y+=playerHex.Y/(150);
					
					@cell=GetCell(globalPosition);
				}
				return@cell;
			}
		}
		return@GetCell(critter.WorldX/10+critter.WorldY/10*Width);
	}
	
	void ShowCells(Critter&critter,Cell&cell)
	{
		if(critter.IsPlayer())
		{
			const bool adm=critter.GetAccess()==(3),
			showStatic=(adm||critter.Param[(703)]!=(3));
			
			uint8 radius=(critter.Skill[(217)]/100)+1;
			int vision=critter.Skill[(217)]/4;
			
			if(adm)
			{
				radius=40;
				vision=255;
			}
			else if(critter.Param[(703)]==(3))
			radius=5;
			
			Cell@[]cells={@cell};
			const uint length=GetCells(cells,cell.Position,radius);
			
			int[]data_color(length*2),
			data_char(length*3);
			
			uint dc=0,dn=0,dch=0,color=0,
			symbol=uint(-1),symbolColor=uint(-1),
			r=0,nr=0;
			Cell@iCell=null;
			CellContent@iContent=null;
			
			for(uint i=0;i<length;i++)
			{
				if(i>nr)
				{
					r++;
					nr+=r*8;
				}
				
				@iCell=@cells[i];
				if(@iCell is null)
				continue;
				ProtoBiom@biom=@iCell.Biom;
				
				color=biom.ColorCell;
				symbol=uint(-1);
				
				@iContent=@iCell.Content;
				
				if(showStatic&&@iContent!is null&&iContent.Info.Flags.Static&&iContent.Info.Visible!=0&&(adm||(vision+iContent.Info.Visible>int(r)*20)))
				{
					color=iContent.Info.ColorCell;
					symbolColor=iContent.Info.ColorSymbol;
					
					if(iContent.Info.ClientSymbol.length()==0)
					{
						ClearLog("Error");
						symbol=83;
					}
					else
					symbol=iContent.Info.ClientSymbol[0];
				}
				else
				{
					if(@biom.ClientSymbol!is null)
					{
						symbol=biom.ClientSymbol[0];
						symbolColor=biom.ColorSymbol;
					}
				}
				
				if(color!=0)
				{
					data_color[dc++]=int((iCell.Position.X&0xFFFF)|(iCell.Position.Y<<16));
					data_color[dc++]=int(color);
				}
				
				if(symbol!=uint(-1))
				{
					data_char[dch++]=int((iCell.Position.X&0xFFFF)|(iCell.Position.Y<<16));
					data_char[dch++]=int(symbolColor);
					data_char[dch++]=int(symbol);
				}
				
			}
			
			data_color.resize(dc);
			critter.RunClientScript("_dr",1,0,0,null,data_color);
			
			data_char.resize(dch);
			critter.RunClientScript("_dr",3,0,0,null,data_char);
		}
	} 
	
	uint CreateCell(const Hexagonal&in position,uint mapId){return CreateCell(position.X,position.Y,mapId);}
	uint CreateCell(const uint16&in x,const uint16&in y,uint mapId)
	{
		Cell@cell=@GetCell(x,y);
		if(@cell is null)
		{
			Log("null cell");
			return 0;
		}
		return CreateCell(cell,mapId);
	}
	
	uint CreateCell(Cell&cell,uint mapId)
	{
		Map@map=null;
		uint locationId=0;
		
		if(mapId!=0)
		{
			@map=GetMap(mapId);
			if(@map is null)
			{
				Log("Map no valid - mapId");
				return 0;
			}
		}
		else if((locationId=cell.MapPack.MapPid)!=0)
		{
			locationId=CreateLocation(cell.Position,locationId);
			if(locationId!=0)
			{
				Location@location=@GetLocation(locationId);
				if(@location!is null)
				{
					@map=location.GetMapByIndex(0);
					mapId=map.Id;
				}
				else
				Log("Location no valid");
			}
			else
			Log("locationId is null LocationPid<"+locationId+">");
		}
		else
		Log("locationId is null <"+cell.MapPack.Name+">"+cell.MapPack.End);
		
		if(@map is null)
		{
			Log("Map no valid");
			return 0;
		}
		
		cell.Content.MapId=mapId;
		map.SetData(56,1);
		
		return map.Id;
	}
	
	void FormatLocation(Location&location)
	{
		Hexagonal locWorld(location.WorldX*0.1,location.WorldY*0.1);
		Cell@cell=@GetCell(locWorld);
		
		if(__StartServerVersion!=0)
		{
			if(location.HashStaticName!=0)
			{
				WorldLocation@worldLocation=this.WorldLocation[location.HashStaticName];
				if(@worldLocation!is null)
				{
					worldLocation=location;
				}
			}
		}
		
		ContentInfo@info=null;
		if(Prototypes.exists("ContentInfo:"+location.GetProtoId()))
		{
			Prototypes.get("ContentInfo:"+location.GetProtoId(),@info);
			Log("Найден контент: "+info.Name+" "+location.GetProtoId()+" координаты: "+uint(location.WorldX*0.1)+" "+uint(location.WorldY*0.1));
		}
		else
		@info=DefaultContent;
		
		if(info.Flags.Ignored)return;
		
		if(@cell is null)
		{
			ClearLog("Клетка не найдена "+(location.WorldX*0.1)+" "+(location.WorldY*0.1)+" удаляем контент "+info.Name);
			DeleteLocation(location.Id);
			return;
		}
		
		if(info.Flags.Encounter&&!cell.MapPack.IsProtoId(location.GetProtoId()))
		{
			ClearLog("Контент не соответствует биому, удаляем "+info.Name);
			ClearLog("Флаги: "+info.Flags.Debug);
			DeleteLocation(location.Id);
			return;
		}
		
		if(IsStart&&info.Flags.SpawnItems)
		{
			Map@[]maps;
			for(uint i=0,iEnd=location.GetMaps(maps);i<iEnd;i++)
			SpawnItemCell(maps[i]);
		}
		
		KindInstance@instance=null;
		if(info.Flags.Hidden)
		{
			if(@cell.HiddenContent!is null)
			{
				cell.HiddenContent.Drop(locWorld,@info);
				cell.HiddenContent.MapId=location.GetMapByIndex(0).Id;
				return;
			}
		}
		else if(@cell.Content!is null)
		{
			cell.Content.Drop(locWorld,@info);
			cell.Content.MapId=location.GetMapByIndex(0).Id;
			return;
		}
		cell=CellContent(locWorld,@info,location.GetMapByIndex(0).Id,@instance);
	}
	
	void Start()
	{
		if(__StartServerVersion==0)
		RunEvent("WorldGeneration");
		
		for(uint y=0;y<Height;y++)
		for(uint x=0;x<Width;x++)
		@GetCell(x,y).Content=null;
		
		Map@[]maps;
		uint mlen=GetAllMaps(0,maps);
		for(uint i=0;i<mlen;i++)
		{
			if(@maps[i]is null)
			continue;
			
			Map@map=@maps[i];
			
			map.SetData(57,0);
			map.SetData(58,0);
		}
		
		Location@[]locations;
		Location@currentLocation=null;
		for(uint i=0,iEnd=GetAllLocations(0,locations);i<iEnd;i++)
		{
			@currentLocation=locations[i];
			if(@currentLocation is null)
			continue;
			FormatLocation(currentLocation);
		}
		
		for(uint i=0,iEnd=Global::World.StaticLocations.length();i<iEnd;i++)
		if(Global::World.StaticLocations[i].Id==0)
		Global::World.StaticLocations[i].Create();
		
		for(uint y=0;y<Height;y++)
		for(uint x=0;x<Width;x++)
		if(@GetCell(x,y).Content is null)
		@GetCell(x,y).Content=@CellContent(GetCell(x,y).Position);
	}
	
	bool global_world_save()
	{
		for(uint i=0,iEnd=AnyDataList.length();i<iEnd;i++)
		{
			AnyDataObject@anyD=AnyDataList[i];
			if(@anyD!is null)
			{
				uint[]@data=anyD.SaveData;
				if(@data is null||data.length()==0)
				{
					if(IsAnyData(anyD.ObjectName+":"+anyD.DictKey))
					EraseAnyData(anyD.ObjectName+":"+anyD.DictKey);
				}
				else SetAnyData(anyD.ObjectName+":"+anyD.DictKey,data);
			}
		}
		return true;
	}
	
	bool global_map_critter_in(Map&map,Critter&critter)
	{
		DypsneaCr(map,critter);
		critter.StatBase[(123)]=-1;
		critter.StatBase[(122)]=-1;
		
		return true;
	}
	
	void ProcessMove(int processType,Critter&critter,Item@car,
	float&currentX,float&currentY,float&toX,float&toY,float&speed,
	uint&encounterDescriptor,bool&waitForAnswer)
	{
		const float oldX=currentX,
		oldY=currentY;
		
		int movementType=((@car!=null)?car.Proto.Car_MovementType:(0)),
		curXi=int(currentX),
		curYi=int(currentY);
		
		Cell@curCell=@GetCell(critter);
		
		if(processType==(0))
		{
			
			float lastDist=(sqrt((((currentX)-(toX))*((currentX)-(toX)))+(((currentY)-(toY))*((currentY)-(toY))))), 
			
			speedPix=speed*float(__GlobalMapMoveTime)/1000.0f,
			speedAngle=atan2(toY-currentY,toX-currentX),
			speedX=cos(speedAngle)*speedPix,
			speedY=sin(speedAngle)*speedPix,
			
			speedMod=1.0f;
			
			if(movementType==(0)&&@curCell!is null)
			speedMod=curCell.Biom.Speed;
			
			uint groupLen=critter.GetFollowGroup((0x01),null);
			speedMod/(groupLen);
			
			if((@car!=null)&&speedMod!=1.0f)
			{
				float pass=float(car.Proto.Car_Passability);
				if(pass>100.0f&&speedMod<1.0f)
				speedMod+=(1.0f-speedMod)*(pass-100.0f)/100.0f;
				else if(pass>100.0f&&speedMod>1.0f)
				speedMod-=(speedMod-1.0f)*(pass-100.0f)/100.0f;
				else if(pass<100.0f&&speedMod<1.0f)
				speedMod-=(1.0f-speedMod)*(100.0f-pass)/100.0f;
				else if(pass<100.0f&&speedMod>1.0f)
				speedMod+=(speedMod-1.0f)*(100.0f-pass)/100.0f;
			}
			
			int oldXi=curXi,
			oldYi=curYi;  
			
			currentX+=speedX*speedMod;
			currentY+=speedY*speedMod;
			
			curXi=int(currentX);
			curYi=int(currentY); 
			
			if(oldXi!=curXi||oldYi!=curYi)
			{
				
				int gmWidth=__GlobalMapWidth*__GlobalMapZoneLength;
				int gmHeight=__GlobalMapHeight*__GlobalMapZoneLength;
				if(curXi<0||curYi<0||curXi>=gmWidth||curYi>=gmHeight)
				{
					if(curXi<0)
					curXi=0;
					if(curXi>=gmWidth)
					curXi=gmWidth-1;
					if(curYi<0)
					curYi=0;
					if(curYi>=gmHeight)
					curYi=gmHeight-1; 
					
					currentX=float(curXi);
					currentY=float(curYi);
					speed=0.0f;
					return;
				} 
				
				int relief=GetGlobalMapRelief(oldXi,oldYi),
				steps=((((((curXi-oldXi)>0)?(curXi-oldXi):-(curXi-oldXi)))>((((curYi-oldYi)>0)?(curYi-oldYi):-(curYi-oldYi))))?((((curXi-oldXi)>0)?(curXi-oldXi):-(curXi-oldXi))):((((curYi-oldYi)>0)?(curYi-oldYi):-(curYi-oldYi)))),
				newXi=oldXi,
				newYi=oldYi;
				
				if(steps>0)
				{
					float xx=float(oldXi),
					yy=float(oldYi),
					oxx=float(curXi-oldXi)/float(steps),
					oyy=float(curYi-oldYi)/float(steps);
					
					for(int i=0;i<steps;i++)
					{
						xx+=oxx;
						yy+=oyy;
						int xxi=int(xx>=0.0f?xx+0.5f:xx-0.5f),
						yyi=int(yy>=0.0f?yy+0.5f:yy-0.5f);
						
						if(xxi==350||yyi==600)
						break;
						
						uint relief_=GetGlobalMapRelief(xxi,yyi);
						if(movementType==(0)&&relief!=0&&relief_==0)
						break;
						if(movementType==(2)&&relief_!=0)
						break;
						
						newXi=xxi;
						newYi=yyi;
					}
				}
				
				if(newXi!=curXi||newYi!=curYi)
				{
					
					currentX=float(newXi);
					currentY=float(newYi);
					speed=0.0f;
					return;
				} 
				
				int oldZoneX=oldXi/__GlobalMapZoneLength,
				oldZoneY=oldYi/__GlobalMapZoneLength,
				curZoneX=curXi/__GlobalMapZoneLength,
				curZoneY=curYi/__GlobalMapZoneLength; 
				
				if(oldZoneX!=curZoneX||oldZoneY!=curZoneY)
				{
					Critter@[]@group=@critter.GetGlobalGroup();
					ScanZone(group,curZoneX,curZoneY);
				} 
				
				float curDist=(sqrt((((currentX)-(toX))*((currentX)-(toX)))+(((currentY)-(toY))*((currentY)-(toY)))));
				if(curDist<=0.01f||curDist>lastDist)
				{
					currentX=toX;
					currentY=toY;
					speed=0.0f;
					return;
				}
			} 
			
			if((@car!=null))
			{
				int fuel=car.Charge;
				int deterioration=car.Deterioration;
				
				if(fuel<=0||deterioration>=int(car.Proto.Car_MaxDeterioration))
				{
					uint str=(fuel<=0?(10255):(10256));
					critter.SayMsg((11),(3),str);
					speed=0.0f;
					return;
				} 
				
				fuel-=car.Proto.Car_FuelConsumption*__GlobalMapMoveTime/500;
				deterioration+=car.Proto.Car_DeteriorationRate*__GlobalMapMoveTime/500;
				if(fuel<0)
				fuel=0;
				if(deterioration>int(car.Proto.Car_MaxDeterioration))
				deterioration=int(car.Proto.Car_MaxDeterioration);
				
				if(fuel!=car.Charge||deterioration!=car.Deterioration)
				{
					car.Charge=fuel;
					car.Deterioration=deterioration;
					car.Update();
				}
			}
			
			Cell@newCell=@GetCell(int(currentX/10),int(currentY/10));
			
			if(Settings.IsDebug)
			{
				newCell.Position.Log("Новая позиция");
				curCell.Position.Log("Начальная позиция");
			}
			
			if(@newCell!is null)
			{
				if(newCell.Biom.Speed==0.0f)
				{
					encounterDescriptor=uint(-1);
					if(@curCell is@newCell)
					Log("Все еще на непроходимой");
					
					currentX=oldX;
					currentY=oldY;
					speed=0.0f;
					return;
				}
				Critter@[]@group=@critter.GetGlobalGroup(); 
				
				Critter@leader=@group[0];
				if(int(group.length())>leader.Stat[(3)]+leader.Perk[(399)])
				{
					leader.SayMsg((11),(3),(10258));
					speed=0.0f;
					return;
				}
				
				ShowCells(critter,newCell);
				if((newCell.Content.Info.Flags.Static&&newCell.Content.Info.Visible>0)||@newCell.Content.CurrentKind!is null)
				encounterDescriptor=uint(-1);
			}
		}
		else if(processType==(1))
		{
			Cell@cell=@GetCell(critter);
			if(@cell!is null)
			{
				CellContent@content=@cell.Content;
				if(@content is null||content.Info.Flags.Encounter)
				{
					if(@content!is null&&content.MapId!=0&&@GetMap(content.MapId)!is null)
					{
						encounterDescriptor=uint(-1);
					}
					else
					{
						CreateCell(cell,0);
						encounterDescriptor=uint(-1);
					}
				}
				else
				(encounterDescriptor=uint(-1));
			}
		}
		else if(processType==(4))
		{
			
			if(critter.Stat[(121)]>0)
			{
				critter.Say((11),"Вы не можете передвигаться при выборе логова.");
				return;
			}
			Critter@[]@group=@critter.GetGlobalGroup(); 
			
			Critter@leader=@group[0];
			if(int(group.length())>leader.Stat[(3)]+leader.Perk[(399)])
			{
				leader.SayMsg((11),(3),(10258));
				if((@car!=null))
				CheckForLocationWithoutParking(critter,car,currentX,currentY);
				return;
			} 
			
			speed=(leader.Skill[(217)]-(100)>0)?((1.0f)+(leader.Skill[(217)]-(100))*(0.1f)):(1.0f);
			if(critter.Param[(703)]==(3))
			speed*=2;
			
			if((@car!=null))
			{
				
				uint strNum=0;
				if(group.length()>car.Proto.Car_CrittersCapacity)
				strNum=(10257);
				else if(car.Charge==0)
				strNum=(10255);
				else if(car.Deterioration>=car.Proto.Car_MaxDeterioration)
				strNum=(10256);
				if(strNum!=0)
				{
					leader.SayMsg((11),(3),strNum);
					speed=0.0f;
					CheckForLocationWithoutParking(critter,car,currentX,currentY);
					return;
				}
				
				speed=car.Proto.Car_Speed*(1.0f)/20.0f;  
				
				if(car.Proto.Car_MovementType==(2))
				{
					if(GetGlobalMapRelief(curXi,curYi)!=0)
					{
						const int maxx=__GlobalMapWidth*__GlobalMapZoneLength,
						maxy=__GlobalMapHeight*__GlobalMapZoneLength;
						const int[]ox={-1,0,1,0},
						oy={0,-1,0,1};
						for(int i=1,ii=__GlobalMapZoneLength;i<=ii;i++)
						{
							for(int j=0;j<4;j++)
							{
								int xx=curXi+ox[j]*i;
								int yy=curYi+oy[j]*i;
								if(xx>=0&&xx<maxx&&yy>=0&&yy<maxy&&GetGlobalMapRelief(xx,yy)==0)
								{
									currentX=float(xx);
									currentY=float(yy);
									
									j=4;
									i=ii;
								}
							}
						}
					}
				}
			}
			else
			{
				
				int speedDiv=100-critter.Perk[(344)]*25;
				if(speedDiv<=0)speedDiv=1;
				speed=speed*100.0f/float(speedDiv);
			}
			
			Cell@cell=@GetCell(critter);
			if(@cell!is null)
			{
				if(cell.Biom.Speed==0.0f)
				{
					critter.Say((11),"Вы не можете быстро найти проход. Стоит поискать детальнее.");
					speed=0.0f;
					return;
				}
			}
		}
		else if(processType==(2)||processType==(5))
		{
			Cell@cell=@GetCell(critter);
			if(@cell!is null)
			ShowCells(critter,cell);
		}  
		
		else if(processType==(7))
		{
			if(GetGlobalMapRelief(curXi,curYi)==0)
			{
				
				Critter@[]@group=@critter.GetGlobalGroup();
				group[0].SayMsg((11),(3),(10259));
				return;
			}
			
			critter.LeaveGlobalGroup();
		}
	}
	
	FileObject@get_ProtoObject(string@name)override
	{
		if(Prototypes.exists(name))
		{
			FileObject@ret=null;
			Prototypes.get(name,@ret);
			return ret;
		}
		return null;
	}
	
	ProtoBiom@GetProtoBiom(string@name)
	{
		string@[]keys;
		ProtoBiom@check=null;
		for(uint i=0,iEnd=Prototypes.keys(keys);i<iEnd;i++)
		{
			Prototypes.get(keys[i],@check);
			if(@check!is null&&check.Name==name)
			return@check;
		}
		return null;
	}
	
	void Log(string@log)
	{
		if(Settings.IsDebug)
		ClearLog(log);
	}
}

Line@GetBorderByDirection(const uint8 direction,Map&map)
{
	MapHash@hash=@Global::World.GetHash(map);
	
	Hexagonal a();
	Hexagonal b();
	
	switch(direction)
	{
		case 0:
		case 1:
		case 2:
		a.X=hash.Min.X;
		a.Y=hash.Min.Y;
		b.X=hash.Min.X;
		b.Y=hash.Max.Y;
		break;
		case 3:
		a.X=hash.Min.X;
		a.Y=hash.Max.Y;
		b.X=hash.Max.X;
		b.Y=hash.Max.Y;
		break;
		case 4:
		case 5:
		case 6:
		a.X=hash.Max.X;
		a.Y=hash.Max.Y;
		b.X=hash.Max.X;
		b.Y=hash.Min.Y;
		break;
		case 7:
		a.X=hash.Max.X;
		a.Y=hash.Min.Y;
		b.X=hash.Min.X;
		b.Y=hash.Min.Y;
		break;
		
		default:
		break;
	}
	
	return@Line(a,b);
}

void Init(string&in,Handle@){manager_add_module(@Global::World,"World",20);}
void Start(string&in,Handle@)
{
	Critter@[]npc;
	for(uint i=0,iEnd=GetAllNpc(0,npc);i<iEnd;i++)
	Global::World.global_critter_init(npc[i],false);
}

void WorldGeneration(string&in,Handle@)
{
	for(uint i=0,iEnd=Global::World.StaticLocations.length();i<iEnd;i++)
	Global::World.StaticLocations[i].Create();
} 

void CellInfo(Critter&critter,int p0,int p1,int p2)
{
	Cell@cell=null;
	if(p0==0&&p1==0)
	@cell=@Global::World.GetCell(critter);
	else if(p0>0||p1>0)
	@cell=@Global::World.GetCell(uint16(p0),uint16(p1));
	
	if(@cell is null)
	return;
	
	CellContent@content=@cell.Content;
	if(@content is null)
	return;
	
	critter.Say((11),"cell<"+cell.Position.X+":"+cell.Position.Y+">");
	critter.Say((11),"MapId: "+content.MapId);
	critter.Say((11),"Visible: "+content.Info.Visible);
}           

void global_process(int processType,Critter&critter,Item@car,
float&currentX,float&currentY,float&toX,float&toY,float&speed,
uint&encounterDescriptor,bool&waitForAnswer)
{
	float oldX=currentX,oldY=currentY;
	Global::World.ProcessMove(processType,critter,car,currentX,currentY,toX,toY,speed,encounterDescriptor,waitForAnswer);
	if(oldX!=currentX||oldY!=currentY)
	{
		critter.LastWorldX=int(oldX);
		critter.LastWorldY=int(oldY);
	}
}   

uint TransitErrorId=0;
void global_invite(Critter&leader,Item@car,uint encounterDescriptor,int combatMode,uint&mapId,uint16&hexX,uint16&hexY,uint8&direction)
{
	Hexagonal result;
	Cell@cell=@Global::World.GetCell(leader);
	if(@cell is null)
	return;
	
	if(cell.Content.MapId!=0)
	{
		encounterDescriptor=uint(-1);
		mapId=cell.Content.MapId;
	}
	else
	mapId=Global::World.CreateCell(cell,0);
	
	Map@map=@GetMap(mapId);
	if(@map!is null)
	{
		int diffX=leader.LastWorldX/10-cell.Position.X,
		diffY=leader.LastWorldY/10-cell.Position.Y;
		
		Line@border=null;
		
		if(diffX==-1)
		@border=GetBorderByDirection(5+diffY+(-2*diffY),map);
		else if(diffX==0)
		@border=GetBorderByDirection(5+(-2*diffY),map);
		else if(diffX==1)
		@border=GetBorderByDirection(1+diffY,map);
		else
		@border=GetBorderByDirection(3,map); 
		
		result.X=border.A.X>border.B.X?
		Random(border.A.X,border.B.X):
		Random(border.B.X,border.A.X);
		
		result.Y=border.A.Y>border.B.Y?
		Random(border.A.Y,border.B.Y):
		Random(border.B.Y,border.A.Y);
		
		cell.Content.MapId=mapId;
		
		if(!result.IsPassed(map))
		{
			for(uint direction=0;direction<6;direction++)
			{
				Hexagonal shift(result);
				map.MoveHexByDir(shift.X,shift.Y,direction,1);
				if(shift.IsPassed(map))
				{
					result=shift;
					break;
				}
			}
			if(!result.IsPassed(map))
			{
				leader.Say((11),"Ошибка перехода, сообщите номер ошибки "+(++TransitErrorId)+" администрации.");
				ClearLog("<TransitError "+TransitErrorId+">");
				ClearLog("border: "+border.Debug);
				ClearLog("map<name:"+map.Name+",Id:"+mapId+"> result hex "+result.X+" "+result.Y);
				ClearLog("Different data "+diffX+" "+diffY);
				ClearLog("Cell data "+cell.Position.X+" "+cell.Position.Y);
				mapId=0;
			}
		}
	}
	else Log("Oups!");
	hexX=result.X;
	hexY=result.Y;
	
}

void ScanZone(Critter@[]&group,int zx,int zy)
{
	uint[]locIds1,locIds2;
	bool locIds2Founded=false;
	
	GetZoneLocationIds(zx,zy,1,locIds1);
	
	for(uint i=0;i<group.length();i++)
	{
		Critter@critter=@group[i];
		if(!critter.IsPlayer())
		continue;
		
		int lookLen=critter.Perk[(346)]!=0?2:1;
		
		if(lookLen==2&&!locIds2Founded)
		{
			GetZoneLocationIds(zx,zy,2,locIds2);
			locIds2Founded=true;
		} 
		
		int mapw=__GlobalMapWidth;
		int maph=__GlobalMapHeight;
		for(int x=-lookLen;x<=lookLen;x++)
		{
			for(int y=-lookLen;y<=lookLen;y++)
			{
				int zx_=zx+x;
				int zy_=zy+y;
				if(zx_>=0&&zx_<mapw&&zy_>=0&&zy_<maph)
				{
					int fog=(zx==zx_&&zy==zy_?(3):(1));
					if(critter.GetFog(zx_,zy_)<fog)
					critter.SetFog(zx_,zy_,fog);
				}
			}
		}
	}
}

void CheckForLocationWithoutParking(Critter&critter,Item&car,float&currentX,float&currentY)
{
	Location@[]locations;
	if(GetVisibleLocations(currentX,currentY,0,critter,locations)!=0)
	{
		Location@location=@locations[0];
		Map@map=@location.GetMapByIndex(0);
		
		bool placeFounded=false;
		Entire[]entires;
		ParseEntires(map,entires,car.Proto.Car_Entrance);
		for(uint i=0;i<entires.length();i++)
		{
			if(map.CheckPlaceForItem(entires[i].HexX,entires[i].HexY,car.GetProtoId()))
			{
				placeFounded=true;
				break;
			}
		}
		
		if(!placeFounded)
		{
			currentX=location.WorldX+int(location.Radius)*(Random(0,1)==0?int(1):int(-1));
			currentY=location.WorldY+int(location.Radius)*(Random(0,1)==0?int(1):int(-1));
		}
	}
}

void TransitCritterToCell(Critter&critter,Scenery&grid)
{
	Cell@cell=@Global::World.GetCell(critter);
	if(@cell is null)
	{
		critter.Say((11),"Bad cell params arguments");
		critter.TransitToGlobal(true);
		return;
	}
	
	Map@fromMap=@critter.GetMap();
	if(@fromMap is null)
	{
		critter.Say((11),"fromMap is null");
		critter.TransitToGlobal(true);
		return;
	}
	
	uint mapId=0;
	critter.TransitDirection=grid.Param[0];
	
	uint16 mapPid=0;
	Cell@transitCell=@GetGridInfo(cell,fromMap,critter.TransitDirection,mapPid,mapId);
	if(@transitCell is null)
	{
		Log("no found transit cell");
		return;
	}
	Hexagonal destCell(transitCell.Position),oldHex;
	if(mapId==0)
	{
		if((mapId=Global::World.CreateCell(destCell,0))==0)
		{
			critter.Say((11),"null mapId.");
			return;
		}
	}
	
	Map@toMap=@GetMap(mapId);
	if(@toMap is null)
	{
		Log("mapId<"+mapId+"> is null");
		return;
	}
	
	if(@toMap is@fromMap)
	{
		Log("toMap is fromMap "+cell.Position.X+" "+cell.Position.Y+" and "+transitCell.Position.X+" "+transitCell.Position.Y);
		return;
	}
	
	if(!oldHex.Entire(fromMap,(255)))
	{
		critter.Say((11),"no found entire");
		return;
	}
	
	{
		Hexagonal offsetCell((critter.HexX-oldHex.X)/(150),(critter.HexY-oldHex.Y)/(150));
		SetMapDirection(critter.TransitDirection,destCell,offsetCell);
	}
	
	Hexagonal toHex;
	toHex.X=(critter.TransitDirection!=5&&critter.TransitDirection!=1?critter.HexX:grid.HexX);
	toHex.Y=(critter.TransitDirection!=3&&critter.TransitDirection!=7?critter.HexY:grid.HexY);
	
	if(cell.Content.Info.Size.X>1||cell.Content.Info.Size.Y>1)
	{
		uint8 tempHexX=(critter.HexX-oldHex.X)/(150),
		tempHexY=(critter.HexY-oldHex.Y)/(150);
		
		if(toHex.X>1)
		{
			
			toHex.X-=tempHexX*(150);
		}
		if(toHex.Y>1)
		{
			
			toHex.Y-=tempHexY*(150);
		}
	} 
	
	oldHex.X=(((int(toHex.X-oldHex.X))>0)?(int(toHex.X-oldHex.X)):-(int(toHex.X-oldHex.X)));
	
	oldHex.Y=(((int(toHex.Y-oldHex.Y))>0)?(int(toHex.Y-oldHex.Y)):-(int(toHex.Y-oldHex.Y)));
	
	Hexagonal begin;
	if(!begin.Entire(toMap,255))
	{
		critter.Say((11),"no found dest entire");
		return;
	}
	SetHexDirection(cell,transitCell,critter.TransitDirection,oldHex);
	
	toHex.X=begin.X+oldHex.X;
	toHex.Y=begin.Y+oldHex.Y;
	
	Hexagonal end;
	if(!end.Entire(toMap,0))
	{
		critter.Say((11),"No found orientation entires");
		return;
	}
	
	if(!toHex.ValidPosition(toMap,begin,end))
	{
		ClearLog("<TransitError "+(++TransitErrorId)+">");
		ClearLog("map<name:"+toMap.Name+",Id:"+toMap.Id+"> result hex "+toHex.X+" "+toHex.Y);
		ClearLog("beginHex: "+begin.X+" "+begin.Y+" oldHex: "+oldHex.X+" "+oldHex.Y+" ");
		critter.Say((11),"No correct toHex position ( ErroId "+TransitErrorId+" )");
		return;
	}
	
	if(!toHex.IsPassed(toMap,begin,end))
	{
		ClearLog("Ошибка перехода, занятый гекс:");
		ClearLog("\tx "+toHex.X+" y "+toHex.Y);
		ClearLog("\tсдвиг позиции");
		
		for(uint direction=0;direction<6;direction++)
		{
			Hexagonal shift(toHex);
			toMap.MoveHexByDir(shift.X,shift.Y,direction,1);
			if(shift.IsPassed(toMap,begin,end))
			{
				toHex=shift;
				break;
			}
		}
	}
	
	if(toHex.IsPassed(toMap,begin,end))
	{
		if(transitCell.Content.Info.Flags.Static||cell.Content.Info.Flags.Static
		||@cell.Content.CurrentKind!is null||@transitCell.Content.CurrentKind!is null
		||cell.Biom.Speed==0.0f||transitCell.Biom.Speed==0.0f)
		{
			if(toMap.GetCrittersHex(toHex.X,toHex.Y,15,(0x03)|(0x20),null)!=0)
			{
				critter.TransitDirection=critter.Dir;
				critter.TransitHexX=toHex.X;
				critter.TransitHexY=toHex.Y;
				critter.TransitMapId=mapId;
				
				ShowAnswerScreenDangerTransit(critter);
			}
			else
			{
				critter.SetWorldPos(transitCell.Position.X*10,transitCell.Position.Y*10);
				toHex.Transit(critter,toMap,critter.Dir);
			}
		}
		else
		{
			critter.TransitDirection=critter.Dir;
			critter.TransitHexX=toHex.X;
			critter.TransitHexY=toHex.Y;
			critter.TransitMapId=mapId;
			
			ShowAnswerScreenTransit(critter);
		}
	}
	else
	critter.Say((11),"Вы не можете туда перейти. Гексы заняты.");
}

void ShowAnswerScreenTransit(Critter&critter)
{
	critter.ShowScreen((2),2,"answer_Transit");
	critter.Say((18),"Выйти на глобальную карту?");
	critter.Say((19+(0)),"Да");
	critter.Say((19+(1)),"Нет, сменить локацию");
}

void ShowAnswerScreenDangerTransit(Critter&critter)
{
	critter.ShowScreen((2),1,"answer_DangerTransit");
	critter.Say((18),"Переход опасен, вы уверены?");
	critter.Say((19+(0)),"Да");
}

void answer_DangerTransit(Critter&critter,uint answerI,string&answerS)
{
	if(critter.TransitMapId==0)
	{
		Log("Error transit. TransitMapId is zero");
		return;
	}
	
	Map@map=@GetMap(critter.TransitMapId);
	if(@map is null)
	{
		critter.Say((11),"Mapid error.");
		return;
	}
	Location@location=map.GetLocation();
	critter.SetWorldPos(location.WorldX,location.WorldY);
	
	if(answerI==0)Hexagonal(critter.TransitHexX,critter.TransitHexY).Transit(critter,map,critter.TransitDirection);
}

void answer_Transit(Critter&critter,uint answerI,string&answerS)
{
	if(critter.TransitMapId==0)
	{
		Log("Error transit. TransitMapId is zero");
		return;
	}
	
	Map@map=@GetMap(critter.TransitMapId);
	if(@map is null)
	{
		critter.Say((11),"Mapid error.");
		return;
	}
	Location@location=map.GetLocation();
	critter.SetWorldPos(location.WorldX,location.WorldY);
	
	if(answerI==1)Hexagonal(critter.TransitHexX,critter.TransitHexY).Transit(critter,map,critter.TransitDirection);
	else if(answerI==0)critter.TransitToGlobal(true);
}

bool SetMapDirection(uint8 direction,Hexagonal&inout destCell,const Hexagonal&in offsetCell)
{
	Cell@cell=Global::World.GetCell(destCell);
	if(@cell is null)
	return false;
	
	if(cell.Position!=cell.Content.Position)
	{
		Cell@parantCell=Global::World.GetCell(cell.Content.Position);
		if(@parantCell is null)
		return false;
		
		destCell.Set(parantCell.Position);
	}
	
	Hexagonal@size=cell.Content.Info.Size;
	
	switch(direction)
	{
		case 0:
		destCell.X++;
		destCell.Y--;
		break;
		case 1:
		destCell.X++;
		destCell.Y+=offsetCell.Y;
		break;
		case 2:
		destCell.X++;
		destCell.Y+=size.Y;
		break;
		case 3:
		destCell.X-=offsetCell.X;
		destCell.Y+=size.Y;
		break;
		case 4:
		destCell.X-=size.X;
		destCell.Y+=size.Y;
		break;
		case 5:
		destCell.X-=size.X;
		destCell.Y+=offsetCell.Y;
		break;
		case 6:
		destCell.X-=size.X;
		destCell.Y--;
		break;
		case 7:
		destCell.X-=offsetCell.X;
		destCell.Y--;
		break;
		default:
		return false;
	}
	
	return(@Global::World.GetCell(destCell)!is null);
}

void SetHexDirection(Cell&cell,Cell&targetCell,uint8&direction,Hexagonal&hex)
{
	Hexagonal mapSize((150),(150));
	bool bigSizeX=false,
	bigSizeY=false;
	
	if(targetCell.Content.Info.Size.X>1||targetCell.Content.Info.Size.Y>1)
	{
		int tempX=targetCell.Content.Position.X-cell.Content.Position.X,
		tempY=targetCell.Content.Position.Y-cell.Content.Position.Y;
		
		if(tempX!=0)
		{
			mapSize.X=((((150)*tempX)>0)?((150)*tempX):-((150)*tempX));
			bigSizeX=true;
		}
		if(tempY!=0)
		{
			mapSize.Y=((((150)*tempY)>0)?((150)*tempY):-((150)*tempY));
			bigSizeY=true;
		}
		
	}
	
	switch(direction)
	{
		case 0:
		hex.X=mapSize.X-hex.X;
		hex.Y=mapSize.Y-hex.Y;
		direction=0;
		break;
		case 1:
		hex.X=mapSize.X-hex.X;
		if(bigSizeY)
		{
			hex.Y=mapSize.Y+hex.Y;
		}
		direction=1;
		break;
		case 2:
		hex.X=mapSize.X-hex.X-(5);
		hex.Y=mapSize.Y-hex.Y;
		direction=2;
		break;
		case 3:
		if(bigSizeX)
		hex.X=mapSize.X+hex.X;
		
		hex.Y=mapSize.Y-hex.Y;
		direction=Random(2,3);
		break;
		case 4:
		hex.X=mapSize.X-hex.X;
		hex.Y=mapSize.Y-hex.Y;
		direction=3;
		break;
		case 5:
		hex.X=mapSize.X-hex.X;
		if(bigSizeY)
		{
			hex.Y=mapSize.Y+hex.Y;
		}
		direction=4;
		break;
		case 6:
		hex.X=mapSize.X-hex.X;
		hex.Y=mapSize.Y-hex.Y-(5);
		direction=5;
		break;
		case 7:
		if(bigSizeX)
		{
			hex.X=mapSize.X+hex.X;
		}
		hex.Y=mapSize.Y-hex.Y;
		direction=(Random(0,1)>0?5:0);
		break;
		default:
		return;
	}
}

void FindTransitHex(Map&map,uint16&hexX,uint16&hexY,uint8 radius,uint8&side)
{
	for(uint16 y=hexY-(radius*0.5),j=hexY+(radius*0.5);y<j;++y)
	{
		for(uint16 x=hexX-(radius*0.5),jj=hexX+(radius*0.5);x<jj;++x)
		{
			Scenery@scenery=@map.GetScenery(x,y,(4053));
			if(@scenery is null)
			continue;
			
			hexX=x;
			hexY=y;
			
			side=scenery.Param[0];
			return;
		}
	}
}

void unsafe_ExitGridClick(Critter&critter,int hexX,int hexY,int protoId,string@,int[]@)
{
	if(critter.IsKnockout()||critter.IsDead())
	{
		critter.Say((11),"Вы не можете перейти.");
		return;
	}
	if(critter.Timeout[(239)]>0)
	{
		critter.Say((11),"Таймаут на переходы. Ждите.");
		return;
	}
	Scenery@grid=@critter.GetMap().GetScenery(hexX,hexY,protoId);
	if(@grid!is null)
	{
		if((((int(critter.HexX-grid.HexX))>0)?(int(critter.HexX-grid.HexX)):-(int(critter.HexX-grid.HexX)))<=(3)&&(((int(critter.HexY-grid.HexY))>0)?(int(critter.HexY-grid.HexY)):-(int(critter.HexY-grid.HexY)))<=(3))
		TransitCritterToCell(critter,grid);
		else critter.Say((11),"Вы слишком далеко от сетки выхода.");
	}
}

int GetCurrentMapIndex(Map&map)
{
	Location@location=map.GetLocation();
	Map@[]maps(0);
	for(uint i=0,iEnd=location.GetMaps(maps);i<iEnd;i++)
	if(map.Id==maps[i].Id)
	return i;
	return-1;
}

int GetCurrentMapIndex(Critter&critter)
{
	Map@map=critter.GetMap();
	if(@map!is null)return GetCurrentMapIndex(map);
	return-1;
}

Cell@GetGridInfo(Cell&cell,Map@currentMap,uint8 direction,uint16&out mapPid,uint&out mapId)
{
	Cell@targetCell=@Global::World.CellToDir(cell,direction);
	if(@targetCell!is null)
	{
		if(@currentMap is null)
		@currentMap=cell.Content.GetMap();
		Map@outMap=null;
		if(@currentMap!is null)
		{
			uint mapIndex=GetCurrentMapIndex(currentMap);
			Location@outLocation=targetCell.Content.Location;
			if(@outLocation!is null)
			{
				if(mapIndex<outLocation.GetMapCount())
				@outMap=outLocation.GetMapByIndex(mapIndex);
				else@outMap=targetCell.Content.GetMap();
			}
		}
		else@outMap=targetCell.Content.GetMap();
		
		if(@outMap!is null)
		{
			mapId=outMap.Id;
			mapPid=outMap.GetProtoId();
			return@targetCell;
		}
		mapId=0;
		mapPid=targetCell.MapPack.MapPid;
	}
	return@targetCell;
}

void unsafe_GetMapPid(Critter&critter,int hexX,int hexY,int protoid,string@,int[]@)
{
	if(hexX<0||hexY<0)return;
	Map@map=@critter.GetMap();
	if(@map is null||map.GetWidth()<=hexX||map.GetHeight()<=hexY)
	return;
	
	Scenery@grid=map.GetScenery(hexX,hexY,protoid);
	int direction=-1;
	protoid=0;
	
	if(@grid!is null)
	{
		direction=grid.Param[0];
		uint mapId=0;
		Cell@cell=Global::World.GetCell(critter);
		if(@cell is null)
		return;
		GetGridInfo(Global::World.GetCell(critter),critter.GetMap(),direction,protoid,mapId);
	}
	critter.StatBase[(122)]=direction;
	critter.StatBase[(123)]=protoid;
}

bool isCellStatic(Critter&cr,Map@map){
	Cell@cell=@Global::World.GetCell(map);
	if(@cell is null)
	{
		cr.Say((11),"[mapID "+map.Id+" has no cell]");
		return false;
	}
	
	CellContent@content=@cell.Content;
	if(@content is null)
	{
		cr.Say((11),"[Cell content not found]");
		return false;
	}
	
	return cell.Content.Info.Flags.Static;
} 

int[]CellAreaInfo(Critter@cr,Map@map){
	bool isDebug=((@cr!=null)&&cr.GetAccess()>=(2));
	int[]result={0,0,0,0,0,0,0,0,0,0};
	
	Cell@cell=@Global::World.GetCell(map);
	if(@cell is null)
	{
		if((@cr!=null))cr.Say((11),"[mapID "+map.Id+" has no cell]");
		return result;
	}
	
	CellContent@content=@cell.Content;
	if(@content is null)
	{
		if((@cr!=null))cr.Say((11),"[Cell content not found]");
		return result;
	}
	string[]values={"","Westland","Forest","Ruins","Mountain","River","Rail","Road","Bridge","CrossRoad"};
	int x=cell.Position.X,y=cell.Position.Y;
	for(int dx=-1;dx<=1;dx++)
	for(int dy=-1;dy<=1;dy++)
	{
		Cell@check=@Global::World.GetCell(x+dx,y+dy);
		if(@check is null){
			if(isDebug&&(@cr!=null))cr.Say((11),"["+(x+dx)+","+(y+dy)+"] is null!");
			result[0]++;continue;}
		ProtoBiom@biom=check.Biom;
		if(@biom is null){
			if(isDebug&&(@cr!=null))cr.Say((11),"["+(x+dx)+","+(y+dy)+"] no biom!");
			result[0]++;continue;}
		string img=biom.Name;
		if(img is null||img.length()==0){
			if(isDebug&&(@cr!=null))cr.Say((11),"["+(x+dx)+","+(y+dy)+"] no type!");
			result[0]++;continue;}
		int index=values.find(img);
		if(index==-1){
			if(isDebug&&(@cr!=null))cr.Say((11),"["+(x+dx)+","+(y+dy)+"] is '"+img+"'!");
			result[0]++;continue;}
		else result[index]++;
	}
	return result;
}

uint GetCellMap(uint16 x,uint16 y)
{
	Cell@cell=@Global::World.GetCell(x*0.1,y*0.1);
	if(@cell is null)
	{
		Log(" cell is null");
		return 0;
	}
	return cell.Content.MapId;
}

void CreateCell(uint16 x,uint16 y,uint mapId)
{
	Global::World.CreateCell(x,y,mapId);
}

int CellLocationCreate(int protoId,int x,int y,int force)
{
	Cell@cell=@Global::World.GetCell(x,y);
	if(@cell is null)
	return-1;
	
	return cell.CellCreate(protoId,force>0?true:false);
}

int CellLocationCreate(int protoId,int x,int y,int wild,int livetime,int force)
{
	Cell@cell=@Global::World.GetCell(x,y);
	if(@cell is null)
	return-1;
	
	return cell.CellCreate(protoId,wild,livetime,force>0?true:false);
}

bool CellLocationDelete(int x,int y)
{
	Cell@cell=@Global::World.GetCell(x,y);
	if(@cell is null)
	return false;
	
	cell.CellDelete();
	return true;
}

int CellLocationSize(int x,int y,int sizeX,int sizeY)
{
	Cell@cell=@Global::World.GetCell(x,y);
	if(@cell is null)
	return-1;
	
	cell.SetSize(sizeX,sizeY);
	return 0;
}

bool CellGetCellSize(uint mapId,uint8&sizeX,uint8&sizeY)
{
	Cell@cell=@Global::World.GetCell(GetMap(mapId));
	if(@cell is null)return false;
	
	sizeX=cell.Content.Info.Size.X;
	sizeY=cell.Content.Info.Size.Y;
	return true;
}

void DypsneaCr(Map&map,Critter&critter)
{
	if(critter.GetTimeEvents((49),null,null,null)<1)
	critter.AddTimeEvent("cte_Dyspnea",5*__TimeMultiplier,(49),1);
}

bool IsDyspneaMap(Map&map)
{
	if(map.GetData(25)>0)
	return true;
	return false;
}

bool IsDyspneaHex(Map&map,uint16 hexX,uint16 hexY)
{
	if(IsDyspneaMap(map))
	{
		if(map.GetProtoId()==(89)&&(443<hexX)&&(hexX<540)&&(369<hexY)&&(hexY<435))
		return false;
		return true;
	}
	return false;
}

uint cte_Dyspnea(Critter&critter,int identifier,uint&rate)
{
	Map@map=@critter.GetMap();
	if(!(@map is null))
	{
		if(IsDyspneaHex(map,critter.HexX,critter.HexY))
		{ 
			
			{
				Item@respirator=critter.GetItem(0,(2));
				if(@respirator!is null&&respirator.GetProtoId()==(1399)&&respirator.Indicator>0)
				{
					uint8 ind=respirator.Indicator;
					if(Random(0,15)==0)
					{
						ind--;
						ind=(((ind)>(100))?(100):(((ind)<(0))?(0):(ind)));
						respirator.Indicator=ind;
						respirator.Update();
					}
					critter.StatBase[(126)]--;
				}
				else critter.StatBase[(126)]-=5;
			}
		}
		else
		{
			if(critter.StatBase[(126)]<100)
			critter.StatBase[(126)]+=critter.Stat[(2)]*5;
		}
	}
	
	critter.ModeBase[(542)]+=1;
	if(critter.Stat[(126)]<=0&&!critter.IsDead())
	InjureCritter(critter,Random(7,16),(0),0,0);
	critter.ModeBase[(542)]-=1;
	
	return 5*__TimeMultiplier;
}

string@LoadFile(string fileName)
{
	file f;
	if(f.open(fileName,"r")!=-1)
	{
		string txt="";
		f.readString(f.getSize(),txt);
		f.close();
		return@txt;
	}
	return null;
}

Kind@GetProtoKind(string&kindName)
{
	if(!Global::World.Prototypes.exists("Kind:"+kindName))
	return null;
	
	FileObject@object=null;
	Global::World.Prototypes.get("Kind:"+kindName,@object);
	if(@object is null)
	return null;
	
	return cast<Kind@>(@object);
}

void SpawnKind(Map&map,string&kindName)
{
	Kind@kind=GetProtoKind(kindName);
	if(@kind is null)
	{
		Log("Object no cast to kind <Kind:"+kindName+">");
		return;
	}
	
	KindInstance(kind,null).Spawn(map);
}

void SpawnKindPart(Map&map,string&kindName,uint16 hexX,uint16 hexY,uint16 count)
{
	Kind@kind=GetProtoKind(kindName);
	if(@kind is null)
	{
		Log("Object no cast to kind <Kind:"+kindName+">");
		return;
	}
	
	Hexagonal@[]hexs={Hexagonal(hexX,hexY)};
	KindInstance(kind,1).Spawn(map,hexs,count);
}

void SpawnKind(Map&map,string&kindName,uint16 hexX,uint16 hexY)
{
	Kind@kind=GetProtoKind(kindName);
	if(@kind is null)
	{
		Log("Object no cast to kind <Kind:"+kindName+">");
		return;
	}
	
	Hexagonal@[]hexs={Hexagonal(hexX,hexY)};
	KindInstance(kind,1).Spawn(map,hexs);
}

void GM_SpawnKind(Critter&gameMaster,int,int,int,string@kindName,int[]@)
{
	if(@kindName is null)
	{
		Log("kindName is not valid");
		return;
	}
	
	Map@map=gameMaster.GetMap();
	if(@map is null)
	{
		Log("map is not valid");
		return;
	}
	
	SpawnKind(map,kindName);
}

void GM_SpawnKindToHex(Critter&gameMaster,int x,int y,int,string@kindName,int[]@)
{
	if(@kindName is null)
	{
		Log("kindName is not valid");
		return;
	}
	
	Map@map=gameMaster.GetMap();
	if(@map is null)
	{
		Log("map is not valid");
		return;
	}
	
	SpawnKind(map,kindName,x,y);
}

void LoadKindProto(string&fileName)
{
	Kind@kind=GetProtoKind(fileName);
	if(@kind!is null&&!kind.ThisIsDebug)
	{
		Log("Kind no debug");
		return;
	}
	
	FileObject@proto=Global::World.ParseProtoTypeFile(fileName,"kind",Kind("DebugPattern"),"./NextDay/");
	if(@proto!is null)
	{
		@kind=cast<Kind@>(@proto);
		kind.ThisIsDebug=true;
	}
}

void GM_LoadKind(Critter&,int,int,int,string@kindName,int[]@)
{
	if(@kindName is null)
	{
		Log("kindName is not valid");
		return;
	}
	
	LoadKindProto(kindName);
}

uint CreateLocation(Hexagonal&coordinate,uint16 locationPid)
{
	uint locationId=::CreateLocation(locationPid,coordinate.X*10+5,coordinate.Y*10+5,null);
	if(locationId!=0&&Global::World.IsStart)
	{
		Location@location=GetLocation(locationId);
		if(@location!is null)
		Global::World.FormatLocation(location);
	}
	return locationId;
} 

void GM_2Cell(Critter&player,int param0,int cellX,int cellY,string@param3,int[]@param4)
{
	Cell@cell=null;
	if(cellX==0&&cellY==0)
	@cell=@Global::World.GetCell(player);
	else@cell=@Global::World.GetCell(uint16(cellX),uint16(cellY));
	
	if(@cell is null)
	return;
	
	player.Say((11),"Cell: "+cell.Position.X+":"+cell.Position.Y);
	CellContent@content=@cell.Content;
	
	if(@content is null)
	{
		player.Say((11),"Cell content not found.");
		return;
	}
	
	switch(TransitToContent(player,content,0,cell,true))
	{
		case Result::Transit::MapNotFound:
		player.Say((11),"Target map not found.");
		break;
		case Result::Transit::FailGenerated:
		player.Say((11),"Failed to generate a map!");
		break;
		case Result::Transit::MapGenerated:
		player.Say((11),"Encounter map generated.");
		break;
		default:break;
	}
}

void GM_CellInfo(Critter&player,int param0,int cellX,int cellY,string@param3,int[]@param4)
{
	Cell@cell=null;
	if(cellX==0&&cellY==0)
	@cell=@Global::World.GetCell(player);
	else@cell=@Global::World.GetCell(uint16(cellX),uint16(cellY));
	
	if(@cell is null)
	return;
	
	string@info="Cell: "+cell.Position.X+":"+cell.Position.Y;
	
	CellContent@content=@cell.Content;
	
	info+="\n---- biom ----";
	info+="\n---- map packet ----";
	info+="\n"+cell.MapPack.Name; 
	
	if(@content is null)
	{
		
		info+="\n---- content ----\nnull";
	}
	else
	{
		
	}
	
	player.Say((42),info);
}

int TransitToContent(Critter&critter,CellContent&content,int entireId,Cell&cell,bool isCreate)
{
	int result=Result::Transit::Okay;
	int mapId=content.MapId;
	
	if(mapId==0)
	{
		if(isCreate)
		mapId=Global::World.CreateCell(cell,0);
		if(mapId==0)
		return Result::Transit::FailGenerated;
		result=Result::Transit::MapGenerated;
	}
	
	Map@map=GetMap(mapId);
	if(@map is null)
	return Result::Transit::MapNotFound;
	
	critter.SetWorldPos(cell.Position.X,cell.Position.Y);
	
	uint countEntires=map.CountEntire(entireId);
	uint8 direction=0;
	Hexagonal hex;
	if(map.GetEntireCoords(entireId,Random(0,countEntires-1),hex.X,hex.Y,direction))
	hex.Transit(critter,map,direction);
	return result;
}

int TransitToContent(Critter&critter,CellContent&content,Hexagonal&hex,Cell&cell,bool isCreate)
{
	int result=Result::Transit::Okay;
	int mapId=content.MapId;
	
	if(mapId==0)
	{
		if(isCreate)
		mapId=Global::World.CreateCell(cell,0);
		if(mapId==0)
		return Result::Transit::FailGenerated;
		result=Result::Transit::MapGenerated;
	}
	
	Map@map=GetMap(mapId);
	if(@map is null)
	return Result::Transit::MapNotFound;
	
	critter.SetWorldPos(cell.Position.X,cell.Position.Y);
	hex.Transit(critter,map,0);
	return result;
}

void TransitToHidden(Critter&critter,int entireId,int,int)
{
	switch(locale_TransitToHidden(critter,entireId))
	{
		case Result::Transit::MapNotFound:
		critter.Say((11),"Target map not found.");
		break;
		case Result::Transit::FailGenerated:
		critter.Say((11),"Failed to generate a map!");
		break;
		case Result::Transit::MapGenerated:
		critter.Say((11),"Encounter map generated.");
		break;
		default:break;
	}
}

int locale_TransitToHidden(Critter&critter,int entireId)
{
	Cell@cell=@Global::World.GetCell(critter);
	if(@cell is null)
	return Result::Transit::CellNotFound;
	
	return TransitToHiddenContent(critter,cell,entireId);
}

int TransitToHiddenContent(Critter&critter,Cell&cell,int entireId)
{
	CellContent@content=@cell.HiddenContent;
	if(@content is null)
	{
		critter.Say((11),"HiddenContent not found.");
		return Result::Transit::NotHiddenContent;
	}
	return TransitToContent(critter,content,entireId,cell,false);
}

bool SwitchContent(Critter&critter,Scenery&scenery,int skill,Item@item)
{
	if(skill==(-1))
	{
		SwitchContent(critter);
		return true;
	}
	
	return false;
}

void SwitchContent(Critter&critter)
{
	CellContent@currentContent=GetContent(critter);
	Cell@cell=@Global::World.GetCell(critter);
	
	if(currentContent.Info.Flags.Hidden)
	{
		Item@[]items;
		uint countItems=cell.Content.GetMap().GetItems(10002,items);
		if(countItems!=0)
		TransitToContent(critter,cell.Content,Hexagonal(items[Random(0,countItems-1)]),cell,false);
		else TransitToContent(critter,cell.HiddenContent,20,cell,false);
	}
	else
	{
		Item@[]items;
		uint countItems=cell.HiddenContent.GetMap().GetItems(10002,items);
		if(countItems!=0)
		TransitToContent(critter,cell.HiddenContent,Hexagonal(items[Random(0,countItems-1)]),cell,false);
		else TransitToContent(critter,cell.HiddenContent,20,cell,false);
	}
}

void TransitToHidden(Item&inout item,bool)
{
	item.SetEvent((4),"_SkillUseTransitToHidden");
}

CellContent@GetContent(Critter&critter)
{
	Map@map=critter.GetMap();
	if(@map is null)
	return null;
	
	Cell@cell=@Global::World.GetCell(critter);
	if(@cell is null)
	return null;
	
	if(@cell.Content!is null&&cell.Content.MapId==map.Id)
	return@cell.Content;
	if(@cell.HiddenContent!is null&&cell.HiddenContent.MapId==map.Id)
	return@cell.HiddenContent;
	return null;
}

bool _SkillUseTransitToHidden(Item&item,Critter&critter,int skill)
{
	if(skill==(-1))
	{
		SwitchContent(critter);
		return true;
	}
	return false;
}

void GM_AddContentSwitcher(Critter&player,int hexX,int hexY,int,string@,int[]@image)
{
	
}

void GM_ChangeItemPicture(Critter&player,int itemId,int hash,int,string@,int[]@)
{
	Item@item=GetItem(itemId);
	if(@item!is null)
	{
		item.PicMap=hash;
		item.Update();
	}
}

void GM_ItemBlock(Critter&player,int itemId,int hash,int,string@,int[]@)
{
	Item@item=GetItem(itemId);
	if(@item!is null)
	{
		(item.Flags=((item.Flags)&(~((0x00000004)))));
		item.Update();
	}
}

void GM_ItemUnBlock(Critter&player,int itemId,int hash,int,string@,int[]@)
{
	Item@item=GetItem(itemId);
	if(@item!is null)
	{
		(item.Flags=(item.Flags)|((0x00000004)));
		item.Update();
	}
}

void GM_TransitContent(Critter&player,int x,int y,int hash,string@,int[]@)
{
	WorldLocation@worldLocation=Global::World.WorldLocation[hash];
	if(@worldLocation!is null&&worldLocation.Id!=0)
	{
		Location@location=worldLocation.Location;
		Hexagonal locWorld(location.WorldX*0.1,location.WorldY*0.1);
		Cell@cell=@Global::World.GetCell(locWorld);
		if(@cell!is null)
		{
			CellContent@content=cell.GetMapContent(location.GetMapByIndex(0));
			if(@content!is null)
			content.Position=Hexagonal(x,y);
		}
	}
}

bool valid_location(Location&location)
{
	if(Global::World.Prototypes.exists("ContentInfo:"+location.GetProtoId()))
	return true;
	
	Hexagonal locWorld(location.WorldX*0.1,location.WorldY*0.1);
	Cell@cell=@Global::World.GetCell(locWorld);
	if(@cell!is null)
	return(@cell.GetMapContent(location.GetMapByIndex(0))!is null);
	return false;
}

void clear(Critter&critter,int,int,int)
{
	Location@[]locations;
	uint count=0;
	for(uint i=0,iEnd=GetAllLocations(0,locations);i<iEnd;i++)
	if(!valid_location(locations[i]))
	{
		DeleteLocation(locations[i].Id);
		count++;
	}
	critter.Say((11),"Удалено "+count+" локаций.");
}
