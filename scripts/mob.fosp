                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               

bool LocIsModoc(uint locPid)
{
	return(locPid<=(1253));
}

bool LocIsCity(uint locPid)
{
	return(locPid<=(32)||locPid==(1216)||locPid==(43)||locPid==96);
}

bool LocIsMasked(uint locPid)
{
	return(locPid==(42));
}

bool LocIsHidden(uint locPid)
{
	return false;
}                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                

shared interface FileObject
{
	string@get_DictKey();
	string@get_ObjectName()const;
	void FormatStringData(string&nameData,string&data);
	FileObject@get_Pattern(string&name)const;
	FileObject@get_Copy(string&name);
	void Prepare(); 
	
	void set_GlobalData(string@name,string@value);          
	
	string@get_GlobalData(string@name);            
	
}

shared interface AnyDataObject
{
	string@get_DictKey();
	string@get_ObjectName()const;
	uint[]@get_SaveData();
	void InitData(uint[]&data);
}

shared interface ManagerObject
{
	FileObject@get_ProtoObject(string@name);
	void ParseProtoTypes(const string&ex,const FileObject&pattern,const string@search);
	FileObject@ParseProtoTypeFile(string&name,const string&ex,const FileObject&pattern,const string@search);
	FileObject@AddPrototype(FileObject@proto);
	FileObject@StringToFileObject(string&name,string&txt,const FileObject&pattern);
}

shared interface ValueAPI{}
shared class SettingsAPI
{
	string Name;
	bool IsDebug;
} 

shared class GlobalData
{
	uint Hash;
	string Value;
	
	GlobalData(string@name)
	{
		Hash=GetStrHash(name);
		Value="";
	} 
	
	void SaveData(uint[]&outArray,uint&position)
	{
		uint len=Value.length();
		
		outArray.resize(position+2+len/2);
		
		outArray[position++]=Hash;
		outArray[position++]=len;
		
		for(uint i=0;i<len;i++)
		{
			outArray[position]|=Value[i++]<<24;
			outArray[position]|=Value[i++]<<16;
			outArray[position]|=Value[i++]<<8;
			outArray[position++]|=Value[i];
		}
	} 
	
	void LoadData(uint[]&in outArray,uint&position)
	{
		Hash=outArray[position++];
		uint len=outArray[position++];
		Value.resize(len);
		
		for(uint i=0;i<len;i++)
		{
			Value[i++]=(outArray[position]>>24)&0xFF;
			Value[i++]=(outArray[position]>>16)&0xFF;
			Value[i++]=(outArray[position]>>8)&0xFF;
			Value[i]=outArray[position++]&0xFF;
			
		}
	}
} 

shared class Hexagonal
{
	Hexagonal(){Reset();}
	Hexagonal(const uint16&in x,const uint16&in y){Set(x,y);}
	Hexagonal(const Hexagonal&master){Set(master);}
	
	Hexagonal(const Critter&master){Set(master.HexX,master.HexY);}
	Hexagonal(const Item&master){Set(master.HexX,master.HexY);}
	Hexagonal(const Scenery&master){Set(master.HexX,master.HexY);}
	
	bool Entire(Map&map,int entNum){return map.GetEntireCoords(entNum,0,X,Y);}
	bool IsPassed(Map&map){return ValidPosition(map)&&map.IsHexPassed(X,Y);}
	bool IsPassed(Map&map,Hexagonal&begin,Hexagonal&end){return ValidPosition(map,begin,end)&&map.IsHexPassed(X,Y);}
	
	bool ValidPosition(Map&map)
	{
		Hexagonal end,begin;
		if(end.Entire(map,0)&&begin.Entire(map,255))
		return ValidPosition(map,begin,end);
		return false;
	}
	
	bool ValidPosition(Map&map,Hexagonal&begin,Hexagonal&end)
	{
		return(X>=begin.X&&Y>=begin.Y
		&&X<=end.X&&Y<=end.Y);
	}
	
	bool Transit(Critter&critter,Map&map){return Transit(critter,map,critter.Dir);}
	bool Transit(Critter&critter,Map&map,uint8 direction)
	{
		if(!IsPassed(map))return false;
		return critter.TransitToMap(map.Id,X,Y,direction);
	}
	
	bool Transit(Critter&critter,uint mapId){return Transit(critter,mapId,critter.Dir);}
	bool Transit(Critter&critter,uint mapId,uint8 direction)
	{
		if(mapId==0)return false;
		Map@map=GetMap(mapId);
		if(@map is null)return false;
		return Transit(critter,map,direction);
	} 
	
	void Set(const uint16&in x,const uint16&in y){X=x;Y=y;}
	void Set(const Hexagonal&in other){Set(other.X,other.Y);}
	void Reset(){X=Y=0;}
	uint Distantion(Hexagonal&other){return GetDistantion(X,Y,other.X,other.Y);}
	
	uint16 X;
	uint16 Y;
	
	bool opEquals(const Hexagonal&in other){return(other.X==X&&other.Y==Y);}
	Hexagonal&opAssign(const Hexagonal&in other)
	{
		Set(other);
		return this;
	}
	
	const uint get_UID(const uint w)const{return X+Y*w;}
	string get_Debug(){return"X:"+X+"Y:"+Y;}
	void Log(string&str){::Log(str+":"+Debug);}
}    

shared class MapHash
{
	MapHash(const uint16&in protoId)
	{
		ProtoId=protoId;
		@Min=null;
		@Max=null;
	}
	
	MapHash&opAssign(Map&map)
	{
		@Min=Hexagonal(0,0);
		@Max=Hexagonal(0,0);
		map.GetEntireCoords(0,0,Max.X,Max.Y);
		map.GetEntireCoords((255),0,Min.X,Min.Y);
		return this;
	}
	
	uint16 ProtoId;
	Hexagonal@Min;
	Hexagonal@Max;
} 

shared class Line
{
	Line(Hexagonal&a,Hexagonal&b){@A=a;@B=b;}
	
	uint get_Length()
	{
		return B.Distantion(A);
	}
	
	uint get_Point(Hexagonal&point)
	{
		return B.Distantion(point);
	}
	
	float get_Module(Hexagonal&point)
	{
		return Point[point]/Length;
	}
	
	Hexagonal@get_opIndex(const uint&in size)
	{
		
		const float mod=float(size/Length);
		return@Hexagonal(A.X+(B.X-A.X)*mod,A.Y+(B.Y-A.Y)*mod);
	} 
	
	Line(Map&map,uint16 grid,MapHash@hash)
	{
		if(@hash is null)
		{
			Hexagonal min,max;
			map.GetTransferParams(min.X,min.Y,max.X,max.Y,grid);
			
			@A=@Hexagonal(min.X,min.Y);
			@B=@Hexagonal(max.X,max.Y);
		}
		else
		{
			if(@hash.Min is null||@hash.Max is null)
			map.GetTransferParams(hash.Min.X,hash.Min.Y,hash.Max.X,hash.Max.Y,grid);
			
			@A=@Hexagonal(hash.Min.X,hash.Min.Y);
			@B=@Hexagonal(hash.Max.X,hash.Max.Y);
		}
	} 
	
	string get_Debug(){return"A<"+A.Debug+">B<"+B.Debug+">";}
	void Log(string&str){::Log(str+":"+Debug);}
	
	Hexagonal@A;
	Hexagonal@B;
}  

import MapHash@GetMapHash(const uint16&in pid)from"world";
import uint CreateLocation(Hexagonal&coordinate,uint16 locationPid)from"world"; 

import ManagerObject@get_objectManager()from"world";                                                                                                                                                               

const uint16[]npc_group_raiders={(337),(338),(339),(340),(341)};
const uint16[]npc_group_mirelurk={(330)};
const uint16[]npc_group_radscorp={(319),(320)};
const uint16[]npc_group_gecko={(316),(317),(327)};
const uint16[]npc_group_rats={(310),(313),(314),(315)};                                                                                                                                                                                     

import bool AddAttackPlane(Critter&npc,uint priority,Critter&target)from"npc_planes";
import bool AddWalkPlane(Critter&npc,uint priority,uint16 hexX,uint16 hexY,uint8 dir,bool run,uint cut)from"npc_planes";
import uint EraseAttackPlane(Critter&npc,Critter&target)from"npc_planes";
import bool IsKindFriend(Critter&cr,Critter&check)from"world";  

const uint16[]Pids_BestialMobs=
{
	(310),
	(311),
	(312),
	(313),
	(314),
	(315),
	(316),
	(317),
	(318),
	(319),
	(320),
	(321),
	(323),
	(324),
	(325),
	(326),
	(327),
	(328),
	(329),
	(330)
};

interface Controller
{
	bool Attack(Critter&target);
}

class MobController:Controller
{
	MobController(Critter&npc)
	{
		@Npc=npc;
	}
	
	bool Attack(Critter&target)override
	{
		return AddAttackPlane(Npc,0,target);
	}
	
	Critter@Npc;
}

class GroupController:Controller
{
	GroupController(Critter&npc)
	{
		ListNpc.resize(0);
		Map@map=npc.GetMap();
		if(@map!is null)
		{
			Critter@[]critters;
			int teamId=npc.Stat[(106)];
			for(uint i=0,iEnd=map.GetCritters(0,(0x03)|(0x20),critters);i<iEnd;i++)
			if(critters[i].Stat[(106)]==teamId)
			ListNpc.insertLast(critters[i]);
			TeamId=teamId;
		}
	}
	
	bool Attack(Critter&target)override
	{
		for(uint i=0,iEnd=ListNpc.length();i<iEnd;i++)
		AddAttackPlane(ListNpc[i],0,target);
		return true;
	}
	
	int TeamId;
	Critter@[]ListNpc;
}

GroupController@GetTeamController(Critter&npc)
{
	return@GroupController(npc);
}

MobController@GetMobController(Critter&npc)
{
	return@MobController(npc);
}

Controller@GetController(Critter&npc)
{
	if(0==npc.Stat[(106)])
	return@GetMobController(npc);
	return@GetTeamController(npc);
}

void RandomStep(Critter&npc)
{
	int rand=Random(0,9);
	if(rand==0||(npc.Mode[(517)]==1&&rand<6))
	{
		npc.MoveRandom();
		npc.ModeBase[(517)]=1;
	}
}

bool TryGoHome(Critter&npc)
{
	if(npc.IsLife())
	{
		uint mapId=0;
		uint16 homeX=0;
		uint16 homeY=0;
		uint8 dir=0;
		npc.GetHomePos(mapId,homeX,homeY,dir);
		if(npc.GetMapId()==mapId&&GetDistantion(homeX,homeY,npc.HexX,npc.HexY)>5)
		{
			npc.DropPlanes();
			return AddWalkPlane(npc,0,homeX,homeY,dir,false,0);
		}
	}
	return false;
}

void MobIdle(Critter&mob)
{
	if(mob.IsCanWalk())
	{
		RandomStep(mob);
		if(mob.Mode[(517)]==1&&TryGoHome(mob))
		mob.ModeBase[(517)]=0;
	}
}

bool MobAttacked(Critter&mob,Critter&attacker)
{
	Controller@controller=@GetController(mob);
	return controller.Attack(attacker);
}

void MobShowCritter(Critter&mob,Critter&critter)
{
	if((0!=mob.Stat[(106)]&&mob.Stat[(106)]==critter.Stat[(106)])||IsKindFriend(mob,critter))
	return;
	
	Controller@controller=@GetController(mob);
	controller.Attack(critter);
}

void MobHideCritter(Critter&npc,Critter&player)
{
	
}

void GM_MobInit(Critter&npc)
{
	npc.SetScript("_MobInit");
}

void GM_MobBossInit(Critter&npc)
{
	npc.SetScript("_BossMobInit");
}

void GM_MobMinionInit(Critter&npc)
{
	npc.PerkBase[(316)]=1;
	npc.SetScript("_MinionMobInit");
}

void _MobInit(Critter&npc,bool firstTime)
{
	npc.SetEvent((0),"MobIdle");
	npc.SetEvent((16),"MobAttacked");
	
	npc.SetEvent((4),"MobShowCritter");
	npc.SetEvent((8),"MobHideCritter");
}

void _HumanoidInit(Critter&npc,bool firstTime)
{
	_MobInit(npc,firstTime);
}

void _BossMobInit(Critter&npc,bool firstTime)
{
	_MobInit(npc,firstTime);
	
}

void _MinionMobInit(Critter&npc,bool firstTime)
{
	_MobInit(npc,firstTime);
}

void _MobsMapInit(Map&map,bool firstTime)
{
	ActivateMobScript(map);
}

void ActivateMobScript(Map&map)
{
	Critter@[]critters;
	for(uint i=0,j=Pids_BestialMobs.length();i<j;i++)
	map.GetCritters(Pids_BestialMobs[i],(0x0F)|(0x20),critters);
	
	for(uint i=0,j=critters.length();i<j;i++)
	{
		if(critters[i].GetScriptId()==0&&(critters[i].Stat[(106)]==0||(critters[i].Stat[(106)]>=24&&critters[i].Stat[(106)]<=33)))
		critters[i].SetScript("_MobInit");
	}
}

void _InitSkinningKnife(Item&item,bool firstTime)
{
	item.SetEvent((2),"e_InitSkinningUse");
}

uint16[]DefaultPidsOrder={(310),(311),(312),(322),
	(321),(318),(318),
	(313),(314),(316),
	(317),(327),(319),
	(320),(319),
	(325),(330),(323),(323),
	(329),(328),(337),
	0,0,(337)
};

uint16 NewPidToDefault(uint16 pid)
{
	if(pid<1000)return pid;
	uint16 start=1000,
	size=30,
	resultPidNumber=(pid-start)/30;
	if(resultPidNumber>=0&&resultPidNumber<DefaultPidsOrder.length())
	
	return(DefaultPidsOrder[resultPidNumber]==0?pid:DefaultPidsOrder[resultPidNumber]);
	else
	return pid;
}

bool e_InitSkinningUse(Item&item,Critter&cr,Critter@onCritter,Item@onItem,Scenery@onScenery)
{
	bool skinned=false;
	if(onCritter.IsDead()&&onCritter.IsNpc())
	{
		Item@darts=onCritter.GetItem((1438),-1);
		if((@darts!=null))
		{
			MoveItem(darts,darts.GetCount(),cr);
			cr.Say((11),"Вы достали дротики.");
		}
		
		if(onCritter.Stat[(187)]!=0)
		{
			cr.Say((11),"Уже освежован.");
			return true;
		}
		
		uint16 npcPid=onCritter.GetProtoId();
		if(npcPid>1000)npcPid=NewPidToDefault(npcPid);
		if(npcPid==10)npcPid=(321);
		
		switch(npcPid)
		{
			case(310):
			cr.AddItem((1551),1);
			if(cr.Perk[(430)]!=0)
			{
				cr.AddItem((540),1);
				cr.Say((11),"Вы сдираете шкуру с крысы.");
			}
			skinned=true;
			break;
			case(311):
			case(312):
			if((cr.Skill[(217)]>60))
			{
				cr.AddItem((1441),1);
				skinned=true;
				cr.Say((11),"Вы срываете хитиновый панцирь.");
			}
			else cr.Say((11),"Не хватает навыков.");
			break;
			case(313):
			cr.AddItem((539),1);
			skinned=true;
			break;
			case(314):
			case(315):
			cr.AddItem((539),1);
			cr.AddItem((1444),1);
			cr.Say((11),"Вы вырезаете желудок кротокрыса.");
			skinned=true;
			break;
			case(316):
			cr.AddItem((1552),1);
			cr.Say((11),"Вы разделываете тушу.");
			if(cr.Perk[(430)]!=0)
			{
				Log("silver2");
				cr.AddItem((276),1);
				cr.Say((11),"Вы сдираете шкуру с гекко.");
			}
			skinned=true;
			break;
			case(317):
			cr.AddItem((1552),1);
			cr.Say((11),"Вы разделываете тушу.");
			if(cr.Perk[(430)]!=0)
			{
				cr.AddItem((277),1);
				cr.Say((11),"Вы сдираете шкуру с гекко.");
			}
			skinned=true;
			break;
			case(318):
			cr.AddItem((539),1);
			skinned=true;
			break;
			case(319):
			if((cr.Skill[(217)]>60))
			{
				cr.AddItem((1441),1);
				skinned=true;
				cr.Say((11),"Вы срываете хитиновый панцирь.");
			}
			else
			cr.Say((11),"Не хватает навыков.");
			break;
			case(320):
			if((cr.Skill[(217)]>60))
			{
				cr.AddItem((1441),1);
				skinned=true;
				cr.AddItem((92),1);
				cr.Say((11),"Вы разделываете гигантского скорпиона.");
			}
			else
			cr.Say((11),"Не хватает навыков.");
			break;
			case(321):
			cr.AddItem((539),4);
			skinned=true;
			break;
			case(322):
			cr.AddItem((365),4);
			skinned=true;
			break;
			case(323):
			cr.AddItem((1440),2);
			skinned=true;
			case(324):
			case(325):
			case(326):
			cr.AddItem((539),2);
			skinned=true;
			break;
			case(327):
			cr.AddItem((539),3);
			if(cr.Perk[(430)]!=0)
			{
				cr.AddItem((556),1);
				cr.Say((11),"Вы сдираете шкуру с гекко.");
			}
			skinned=true;
			break;
			case(328):
			cr.AddItem((1440),4);
			cr.AddItem((1443),1);
			cr.Say((11),"Вы извлекаете железу твари.");
			skinned=true;
			break;
			case(329):
			cr.AddItem((1440),1);
			cr.AddItem((1443),1);
			cr.Say((11),"Вы извлекаете железу твари.");
			skinned=true;
			break;
			case(330):
			if((cr.Skill[(217)]>100)&&cr.Perk[(430)]>=2)
			{
				cr.AddItem((1442),1);
				skinned=true;
				cr.Say((11),"Вы срываете панцирь с мяса болотника.");
			}
			else
			cr.Say((11),"Не хватает навыков.");
			break;
			case(338):
			case(341):
			case(345):     
			
			break;
			
			case(337):
			case(339):
			case(340):
			case(342):
			case(343):
			case(344):
			case(346):     
			
			break;
			
			case(347):
			case(348):     
			
			break;
			
			case(349):     
			
			break;
		}
	}
	else if(onCritter.IsDead()&&!onCritter.IsNpc())
	{
		if(onCritter.Stat[(187)]!=0)
		{
			cr.Say((11),"Уже освежован.");
			return true;
		}        
		
	}
	if(skinned)
	{
		onCritter.StatBase[(187)]=1;
	}
	return true;
}